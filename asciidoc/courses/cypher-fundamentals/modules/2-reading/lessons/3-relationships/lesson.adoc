= Finding Relationships
:type: quiz
:order: 3


[TIP]
.Our Goal
As a *movie fanatic* +
I would like to *find movies for a particular actor* +
So that I can *watch a movie this evening*


In the previous lesson, we used the `MATCH` clause to find the node in our database that represented _Tom Hanks_.

[source,cypher, role = noplay]
----
MATCH (p:Person {name: 'Tom Hanks'})
RETURN p
----

We can extend the pattern in the `MATCH` clause to _traverse_ through all relationships with a type of `ACTED_IN` to any node.
Our domain model shows that the _ACTED_IN_ relationship goes in an outgoing direction from the Person so we can add the direction in our pattern.
We often refer to this as a *traversal*.

[source,Partial,role=nocopy noplay]
----
//incomplete code
MATCH (p:Person {name: 'Tom Hanks'})-[:ACTED_IN]->()
----

Our data model dictates that the node at the other end of that relationship will be _Movie_ node, so we don't necessarily need to specify the `:Movie` label in the node - instead we will use the variable `m`.

[source,cypher, role = noplay]
----
MATCH (p:Person {name: 'Tom Hanks'})-[:ACTED_IN]->(m)
RETURN m.title
----

This code returns the titles of all moves that _Tom Hanks_ acted in.

If we had multiple _types_ of nodes at the end of the _ACTED_IN_ relationship in our graph, we could make sure that we only return movies.

[source,cypher, role = noplay]
----
MATCH (p:Person {name: 'Tom Hanks'})-[:ACTED_IN]->(m:Movie)
RETURN m.title
----

Because our graph only has _Movie_ nodes that have incoming _ACTED_IN_ relationships, this query returns the exact same results as the previous query.

== Check your understanding

include::questions/1-complete-query.adoc[]

include::questions/2-directors.adoc[]

[.summary]
== Summary

In this lesson, you learned how to traverse patterns in the graph with your queries using relationships.
In the next challenge, you will demonstrate your skills for traversing the graph.

