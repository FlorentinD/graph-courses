= Specializing RATED Relationships
:type: challenge
:order: 3
:sandbox: true

In the previous Challenge, you added a number of specialized relationships to the graph for the _ACTED_IN_ and _DIRECTED_ relationships.
This Challenge has 3 steps.

In our current graph, there are _RATED_ relationships between _User_ nodes and _Movie_ nodes.

Suppose we wanted to improve the performance of this query:

Use case #9: What users gave a movie a rating of 5?

*Step 1:* Run this Cypher code to test this use case with the movie, Apollo 13.

[source,cypher]
----
MATCH (u:User)-[r:RATED]-(m:Movie)
WHERE m.title = 'Apollo 13' AND
r.rating = 5
RETURN u.name as Reviewer
----

It should return Sandy Jones.

What if there were thousands of Users in the graph. This query would need to traverse all _RATED_ relationships and evaluate the _rating_ property.
For a large graph, more evaluations mean longer query processing time.

In this challenge, you will specialize the _RATED_ relationships to reflect the rating.
Unlike the refactoring where we removed the _genres_ and _languages_ properties from the nodes, we will not remove the _rating_ property from the _RATED_ relationship.
This is because we may need it for a query that has a reference to the relationship and needs to return the _rating_ value.

This is the instance model you will refactor toward:

image::images/instance-specialize-rated.png[Specializing RATED,width=400,align=center]

This challenge has two more steps:

[start=2]
. Modify and run the query to specialize the _RATED_ relationship.
. Rewrite and run the query using the specialized relationships for the use case:  *What users gave a movie a rating of 5?*

*Step 2:* Copy the query below into the query pane, modify it to refactor the graph as described above, and then run it:

[TIP]
--
Change the from node to be _User_, the relationship to _RATED_ and use [copy]#toString(r.rating)# to dynamically create the relationship.
--

[source,cypher, role=noplay]
----
MATCH (n:Director)-[r:DIRECTED]->(m:Movie)
CALL apoc.merge.relationship(n,
                              'DIRECTED_' + left(m.released,4),
                              {},
                              {},
                              m,
                              {}) YIELD rel
RETURN COUNT(*) AS `Number of relationships merged`
----

Your modified code should create 5 relationships.

*Step 3:* Modify and run this query for the use case so that it uses the specialized relationships.

Copy this query into the query pane, modify it use the specialized relationship, and then run it:

[source,cypher, role=noplay]
----
MATCH (u:User)-[r:RATED]-(m:Movie)
WHERE m.title = 'Apollo 13' AND
r.rating = 5
RETURN u.name as Reviewer
----

It should return Sandy Jones.


include::./questions/verify.adoc[leveloffset=+1]

[.summary]
== Summary

In this challenge, you demonstrated that you can refactor the graph to specialize the _RATED_ relationships.

In the next module, you will learn about creating intermediate nodes.
