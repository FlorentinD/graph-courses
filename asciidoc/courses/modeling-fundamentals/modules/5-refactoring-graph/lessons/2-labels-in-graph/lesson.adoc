= Labels
:type: quiz
:order: 2
:sandbox: true

[.video]
video::xxxx[youtube,width=560,height=315]


[.transcript]
== Labels at runtime

In Neo4j, labels serve as an index to nodes.
Using a label helps to reduce the number of nodes that are retrieved.

For example:

`MATCH (n) RETURN n` returns all nodes in the graph.

`MATCH (n:Person) RETURN n` returns all _Person_ nodes in the graph.

Your goal in your modeling should be to reduce the number of nodes that are retrieved.

If _Person_ nodes also had a label which is the country that a person is from, then you could used this Cypher code to retrieve all people from the US:

`MATCH (n:US) RETURN n` returns all _Person:US_ nodes in the graph.

But having a label that is specific like this might be overkill, especially if the query could be:

`MATCH (n:Person) WHERE n.country = 'US' RETURN n`

In Cypher you can parameterize literals in queries so the second query would be more flexible as:

`MATCH (n:Person) WHERE n.country = $country RETURN n`

You cannot parameterize labels so keeping the country as a property makes the Cypher code more flexible.

But if you have a strong use case for having multiple labels for a node, you should do so.

=== Do not overuse labels

You should use labels wisely in your data model.
They should be used if it will help with *most* of your use cases.
A best practice is to limit the number of labels for a node to 4.

Here is an example of overuse of labels:

image::images/label-overuse.png[Label overuse,width=400,align=center]

Here we see _Person_ nodes that have a label representing the country that a Person is from like we described earlier.

In addition, we see multiple labels for _Movie_ nodes.
The label represents the languages available for a movie.

This is another similar scenario where you must decide if an important use case is related to the language of a movie.
Again if the use of a property for a node will suffice, then it is best to not have the label.

=== Refactor the data model: Adding a label

Here is an example where adding a label will help our queries at runtime.

What if we added a new use case:

*10. What actors were born before 1950?*

The Cypher query to test this use case is the following. Execute this query:

[source,cypher]
----
MATCH (p:Person)-[:ACTED_IN]-()
WHERE p.born < '1950'
RETURN p.name
----

Here is what this Cypher query does:

. A node by label scan to retrieve all _Person_ nodes.
. Tests the born property for the nodes retrieved to filter them.
. Determines which of these filtered nodes have the outgoing _ACTED_IN_ relationship.

You can use the `PROFILE` keyword to see the performance for a a query.
Because the cache is automatically populated, it is sometimes hard to measure performance with a small dataset.
That is, db hits and elapsed time may not be comparible.
What you can see, however is the number of rows that are retrieved in the query and this number can be compared.


Execute this query:

[source,cypher]
----
PROFILE MATCH (p:Person)-[:ACTED_IN]-()
WHERE p.born < '1950'
RETURN p.name
----

In the first step of this query, we see that 5 rows are returned.
You can imagine that if this were a fully-loaded graph with millions of nodes, in step 1, it would need to retrieve a lot of _Person_ nodes, some of which are not actors.
One way that you can optimize this retrieval is to change the data model to include an Actor label for a Person node.

Then the initial node by label scan would only retrieve the Actor nodes.

Here is the refactored instance model we will create in the graph:

image::images/added-actor-label-instance.png[Added Actor label,width=400,align=center]

=== Refactor the graph

With Cypher, you can easily transform the graph.

Execute this Cypher code to add the _Actor_ label to the appropriate nodes:

[source,cypher]
----
MATCH (p:Person)
WHERE exists ((p)-[:ACTED_IN]-())
SET p:Actor
----

There are 5 _Person_ nodes in the graph. It should set 4 of them with the _Actor_ label.

And you need to test the new use case:

*10. What actors were born before 1950?*

With the refactoring we change the Cypher query for this use case to:

[source,cypher]
----
MATCH (p:Actor)
WHERE p.born < '1950'
RETURN p.name
----

Let's look at the profile for this query:

[source,cypher]
----
PROFILE MATCH (p:Actor)
WHERE p.born < '1950'
RETURN p.name
----

It should return the same results as before. But, we see only 4 rows retrieved.

Note that if this graph had many more nodes (millions), you would see much greater differences in rows retrieved.


=== Retesting after refactoring

After you have refactored the graph, you should revisit all queries for your use cases.

You should first determine if any of the queries need to be rewritten to take advantage of the refactoring.

Next, we will rewrite some of our queries and test the queries we know are affected by the change to the data model.

==== 1. What people acted in a movie?

We have rewritten this query to use the _Actor_ label.

Run this Cypher code to test this use case using the movie, Sleepless in Seattle.

[source,cypher]
----
MATCH (p:Actor)-[:ACTED_IN]-(m:Movie)
WHERE m.title = 'Sleepless in Seattle'
RETURN p.name AS Actor
----

It should return two names of actors, Tom Hanks, and Meg Ryan.

==== 3. What movies did a person act in?

We have rewritten this query to use the _Actor_ label.

Run this Cypher code to test this use case using the person, Tom Hanks.

[source,cypher]
----
MATCH (p:Actor)-[:ACTED_IN]-(m:Movie)
WHERE p.name = 'Tom Hanks'
RETURN m.title AS Movie
----

It should return the movies Apollo 13 and Sleepless in Seattle.

==== 5. Who was the youngest person to act in a movie?

We have rewritten this query to use the _Actor_ label.

Run this Cypher code to test this use case with the movie, Hoffa.

[source,cypher]
----
MATCH (p:Actor)-[:ACTED_IN]-(m:Movie)
WHERE m.title = 'Hoffa'
RETURN  p.name AS Actor, p.born as `Year Born` ORDER BY p.born DESC LIMIT 1
----

It should return Danny DeVito with his birth year.

==== 6. What role did a person play in a movie?

We have rewritten this query to use the _Actor_ label.

Run this Cypher code to test this use case with the movie, Sleepless in Seattle and the person, Meg Ryan.

[source,cypher]
----
MATCH (p:Actor)-[r:ACTED_IN]-(m:Movie)
WHERE m.title = 'Sleepless in Seattle' AND
p.name = 'Meg Ryan'
RETURN  r.role AS Role
----

It should return Annie Reed.

==== 8. What drama movies did an actor act in?

We have rewritten this query to use the _Actor_ label.

Run this Cypher code to test this use case with the person, Tom Hanks.

[source,cypher]
----
MATCH (p:Actor)-[:ACTED_IN]-(m:Movie)
WHERE p.name = 'Tom Hanks' AND
'Drama' IN m.genres
RETURN m.title AS Movie
----

If you were to change 'Drama' to 'Comedy' in this query, it would return a different result.


==== 10. What actors were born before 1950?

For completeness of our testing, this is our new query that we tested earlier

Run this Cypher code to test this use case with the movie, Apollo 13.

[source,cypher]
----
MATCH (p:Actor)
WHERE p.born < '1950'
RETURN p.name
----

It should return the actors, Danny DeVito and Jack Nicholson

=== Avoid semantically orthogonal labels

You should be careful not to use the same type of label in different contexts.
For example, using the region for all types of nodes is not useful for most queries.

Here is an example:

image::images/orthogonal-labels.png[Orthogonal labels,width=400,align=center]

=== Avoid class hierarchies

You also want to avoid labeling your nodes to represent hierarchies.

You should not do this:

image::images/actor-hierarchy.png[Hierarchy of labels,width=400,align=center]

Instead, you should do this:

image::images/membership-instead-of-hierarchy.png[Membership instead,width=400,align=center]


== Check your understanding


include::questions/1-why-add-labels.adoc[]

include::questions/2-num-labels.adoc[]

include::questions/3-profile-query.adoc[]

[.summary]
== Summary

In this lesson, you learned some best practices for using labels and how to refactor a graph to add labels.
In the next challenge, you refactor the graph to add another label.