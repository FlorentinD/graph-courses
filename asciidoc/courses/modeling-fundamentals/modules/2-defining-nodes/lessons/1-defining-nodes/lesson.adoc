= Modeling Nodes
:type: quiz
:order: 1
:usecase: blank-sandbox
:sandbox: true

[.video]
video::xxxx[youtube,width=560,height=315]


[.transcript]

== Defining labels

Entities are the dominant nouns in your application use cases:

. What *ingredients* are used in a *recipe*?
. Who is married to this *person*?

The entities of your use cases will be the labeled nodes in the graph data model.

In the Movie domain, we use the *nouns* in our use cases to define the labels, for example:

. What *people* acted in a *movie*?
. What *person* directed a *movie*?
. What *movies* did a *person* act in?

Here are some of the labeled nodes that we will start with.

image::images/movie-person-labels.png[Starting labels,width=400,align=center]

=== Node properties

Node properties are used to:

* Uniquely identify a node.
* Answer specific details of the use cases for the application.
* Return data.

For example, in a Cypher query, properties are used to:

* Anchor (where to begin the query).
** MATCH (p:Person *{name: 'Tom Hanks'}*)-[:ACTED_IN]-(m:Movie) RETURN m
* Traverse the graph (navigation).
** MATCH (p:Person)-[:ACTED_IN]-(m:Movie *{title: 'Apollo 13'}*)-[:RATED]-(u:User) RETURN p,u
* Return data from the query.
** MATCH (p:Person {name: 'Tom Hanks'})-[:ACTED_IN]-(m:Movie) RETURN *m.title, m.released*

=== Unique identifiers in the Movie graph

In the _Movie_ graph, we use the following properties to uniquely identify our nodes:

* Person.tmdbId
* Movie.tmdbId

=== Properties for nodes

In addition to the _tmdbId_ that is used to uniquely identify a node, we must revisit the use cases to determine the types of data a node must hold.

Here is a list of our use cases specific to _Person_ and _Movie_ nodes that we will focus on.
These use cases inform us about the data we need in _Movie_ and _Person_ nodes.

. What people acted in a movie?
.. Retrieve a movie by its *title*.
.. Return the *names* of the actors.
. What person directed a movie?
.. Retrieve a movie by its *title*.
.. Return the *name* of the director.
. What movies did a person act in?
.. Retrieve a person by their *name*.
.. Return the *titles* of the movies.
. How many users rated a movie? (we will look at this later)
. Who was the youngest person to act in a movie?
.. Retrieve a movie by its *title*.
.. Evaluate the *ages* of the actors.
.. Return the *name* of the actor.
. What role did a person play in a movie? (we will look at this later)
. What is the highest rated movie in a particular year according to imDB?
.. Retrieve all movies *released* in a particular year.
.. Evaluate the *imDB ratings*.
.. Return the movie *title*.
. What drama movies did an actor act in?
.. Retrieve the actor by *name*.
.. Evaluate the *genres* for the movies the actor acted in.
.. Return the movie *titles*.
. What reviewers gave a mo vie a rating of 5? (we will look at this later)

Given this information from the use cases, here are the properties we will define for the _Movie_ nodes:

* Movie.title (string)
* Movie.released (date)
* Movie.imdbRating (decimal between 0-10)
* Movie.genres (list of strings)

Here are the properties we will define for the _Person_ nodes:

* Person.name (string)
* Person.born (date)
* Person.died (date)

Note: The _died_ property will be optional.

Here is the initial data model:

image::images/before-challenge1-data-model.png[Data model,width=400,align=center]

And here is the initial instance model you will be working with:

image::images/before-challenge1-instance-model.png[Instance model,width=400,align=center]

Run this Cypher code to add the Person and Movie nodes to the graph which will serve as our initial instance model:

[TIP]
Click the *Run in Sandbox* button to the top right of the code sample to open the Sandbox to the right and run the query.

[source,cypher]
----
MATCH (n)
DETACH DELETE n;
MERGE (:Movie {title: 'Apollo 13', tmdbId: 568, released: '1995-06-30', imdbRating: 7.6, genres: ['Drama', 'Adventure', 'IMAX']})
MERGE (:Person {name: 'Tom Hanks', tmdbId: 31, born: '1956-07-09'})
MERGE (:Person {name: 'Meg Ryan', tmdbId: 5344, born: '1961-11-19'})
MERGE (:Person {name: 'Danny DeVito', tmdbId: 518, born: '1944-11-17'})
MERGE (:Movie {title: 'Sleepless in Seattle', tmdbId: 858, released: '1993-06-25', imdbRating: 6.8, genres: ['Comedy', 'Drama', 'Romance']})
MERGE (:Movie {title: 'Hoffa', tmdbId: 10410, released: '1992-12-25', imdbRating: 6.6, genres: ['Crime', 'Drama']})
MERGE (:Person {name: 'Jack Nicholson', tmdbId: 514, born: '1937-04-22'})
----


You can verify that the nodes have been created with this code:

[source,cypher]
----
MATCH (n) RETURN n
----

You should have 7 nodes in the graph.

== Check your understanding

include::questions/1-labels.adoc[]

include::questions/2-properties.adoc[]

[.summary]
== Summary

In this lesson, you learned that a good starting point for your data modeling is to come up with a set of use cases and identify the entities from the use cases.
In the next challenge, you will further develop the model by adding another labeled node to the model.