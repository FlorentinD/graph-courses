= Subqueries
:type: quiz
:sandbox: true

//[.video]
//video::ImKvXY72SA0[youtube,width=560,height=315]

[.transcript]

== What is a subquery?

When you execute a series of `MATCH` clauses, all nodes and relationships retrieved are in memory.
If the memory requirements for a set of `MATCH` clauses exceed the VM configured, the query will fail.

A subquery is a set of Cypher statements that execute within their own scope.
A subquery is typically called from an outer enclosing query.
Using a subquery, you can limit how much data needs to be in memory.

Here are some important things to know about a subquery:

* A subquery returns values referred to by the variables in the `RETURN` clause.
* A subquery cannot return variables with the same name used in the enclosing query.
* You must explicitly pass in variables from the enclosing query to a subquery.

== Performing subqueries with `CALL`

In a `CALL` clause, you specify a query that returns, typically a node or set of nodes.
The set of nodes returned in the `CALL` clause can be used by the outer query.

Here is a simple example:

[source,cypher]
----
CALL
{MATCH (p:User)-[:RATED]->(m:Movie)
RETURN  m}
MATCH (m) WHERE m.year = 2000
RETURN m.title, m.released
----

The subquery is demarcated by the {}s here.
The subquery returns a Movie node, m for every Movie in the graph that has a rating.
Each node, m that is returned by the subquery is then tested to see if it was released in the year 2000.

The alternative code to do the same thing without a subquery is less efficient (use of memory):

[source,cypher]
----
MATCH (p:User)-[:RATED]->(m:Movie)
WHERE m.year = 2000
RETURN m.title, m.released
----

This query will retrieve all paths for RATED and test whether the movie was released in 2000.
This requires a lot more memory.

=== Passing variables into a subquery

Here is an example where the subquery is executed after the initial query and the enclosing query passes a variable, m into the subquery.

[source,cypher]
----
MATCH (m:Movie)
CALL {
    WITH m
    MATCH (m)<-[r:RATED]-(u:User)
     WHERE r.rating = 5
    RETURN u
}
RETURN m.title, count(u) AS numReviews ORDER BY numReviews DESC
----

The first `MATCH` returns a row for every movie, m in the graph.
It passes the Movie node,m to the subquery.
Then within the subquery, the query is done to find all users who gave that movie a rating of 5.
The subquery returns the user nodes.
Back in the enclosing query, the title is returned, and the count of the number of rows returned from the subquery.

Using subqueries enables  you to reduce memory requirements for your queries.

=== Combining query results with UNION

As your queries become more complex, you may need to combine the results of multiple queries.
You can do so with `UNION`.
With `UNION`, the queries you are combining must return the same properties

Here is a simple example:

[source,cypher]
----
MATCH (m:Movie) WHERE m.year = 2000
RETURN {type:"movies", theMovies: collect(m.title)} AS Data
UNION ALL
MATCH (a:Actor) WHERE a.born.year > 2000
RETURN { type:"actors", theActors: collect(DISTINCT a.name)} AS Data
----

The first query returns an object with a type property of "movies" and a theMovies property that is a list of movies.
It returns this object as a variable named data
The second query returns an object with a type property of "actors" and a theActors property that is a list of accor names.
It returns this object as a variable named data
Because both queries return a variable named data, we can combine the results using `UNION ALL`.

=== Using UNION with subqueries

Here is an example that uses UNION within a subquery:

[source,cypher]
----
MATCH (p:Person)
CALL {
  WITH p
  OPTIONAL MATCH (p)-[:ACTED_IN]->(m:Movie)
  RETURN m.title + ": " + "Actor" as work
UNION
  WITH p
  OPTIONAL MATCH (p)-[:DIRECTED]->(m:Movie)
  RETURN m.title+ ": " +  "Director" as work
}
RETURN p.name, collect(work) LIMIT 100
----

With this query each Person node is retrieved and is passed to the subquery.
If that Person acted in the movie, its title with the Actor suffix is returned.
The second part of the subquery does the same for the DIRECTED relationships.
The work results are combined and collected.
The result is the name of the person and their Actor or Director titles.

== Check your understanding

include::questions/1-complete-query.adoc[leveloffset=+1]
include::questions/2-select-answer.adoc[leveloffset=+1]

[.summary]
== Summary

In this lesson, how to call a subquery in Cypher that will help reduce memory requirements for your queries.
In the next challenge, you will write subqueries and also write code to use the `UNION` keyword.
