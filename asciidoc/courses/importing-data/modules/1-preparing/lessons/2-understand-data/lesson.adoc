= Understanding the Source Data
:type: quiz

//[.video]
//video::jEIE_b1MzAE[youtube,width=560,height=315]

//https://youtu.be/jEIE_b1MzAE


[.transcript]
== CSV file structure

A CSV file represents rows of a relational table.
When CSV files are created from your relational database, you must determine:

[square]
* Whether the CSV file will have header information, describing the names of the fields.
* What the delimiter will be for the fields in each row.

Including headers in the CSV file reduces syncing issues.
If the size of the CSV files representing a table is extremely large (~ 1M rows), it is sometimes better to separate the headers from the data, especially if multiple files will be split to use the same set of headers.

=== Example CSV files

Here are examples of CSV files with and without headers:

image::images/with-without-headers.png[With and without headers,width=600,align=center]

In these examples, the comma (,) is the field terminator.
This is the default that Cypher uses.
If the source CSV files use a different field terminator, you must specify the `FIELDTERMINATOR` in your `LOAD CSV` clause.

== Normalized data

Data normalization is common in relational models.
This enables you to have CSV files that correspond to a relational table where an ID is used to identify the relationships.

Here is an example where we have normalized data for people, movies, and roles:

image::images/normalized-data.png[Normalized data,width=600,align=center]

Notice that the *people.csv* file has a unique ID for every person and the *movies1.csv* file has a unique ID for every movie.
The *roles.csv* file is used to relate a person to a movie and provide the characters.
This is the roles data that could be used to create the _:ACTED_IN_ relationship that you have seen in the Movie graph.

== De-normalized data

Here is an example where we have de-normalized data for the same dataset:

image::images/denormalized-data.png[Denormalized data,width=600,align=center]

With de-normalized data, the data is represented by multiple rows corresponding to the same entity, which will be loaded as a node.
The difference, however, is that de-normalized data typically represents data from multiple tables in the RDBMS.
For example, the movie and person data (including the ID) is repeated in multiple rows in the file, but a row represents a particular actor's role in a particular movie.
That is, a Movie and Person data will be represented in multiple rows, but an actor's role will be represented by a single row.

In this course, you will be importing both normalized and de-normalized data.

== IDs must be unique

When you load data from CSV files, you rely heavily upon the ID's specified in the file.
In most cases, the ID can be used as a unique property value for each node.
If the IDs in your CSV file are not unique for the same entity (node), you will have problems when you load the data and try to create relationships between existing nodes.

image::images/unique-ids.png[Unique Ids,width=600,align=center]

You will learn later in this module that you must create uniqueness constraints in the graph before you load the data.

== Check your understanding

include::questions/1-field-terminator.adoc[]
include::questions/2-de-normalized-data.adoc[]

[.summary]
== Summary

In this lesson, you learned how to understand the organization of CSV data you will import and that you must have unique IDs for all nodes that will be created.
In the next lesson, you will learn about the data model we will use for implementing the import of the data.
