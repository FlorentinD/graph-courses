= Importing with Cypher
:type: challenge
:sandbox: true

In this Challenge, you will add more data to the graph you have been working with.
You will use different CSV files that are much larger than what you have used previously.

[IMPORTANT]
Although you can execute the Cypher code in this challenge, you can only verify your results of this Challenge if you have not completed all previous Challenges.

This challenge has 4 steps:

. Import _Movie_ and _Genre_ data.
. Import _Person_ data for actors.
. Import _Person_ data for directors.
. Import _User_ data.

== Step 1: Importing _Movie_ and _Genre_ data

This is the Cypher code for first pass we will make through the 2-movieData.csv file to create the _Movie_ and _Genre_ nodes.
Notice in this code we perform all of the necessary transformations of types when we set the properties for the _Movie_ node.
We use `MERGE` to only create the _Movie_ and _Genre_ nodes if they do not already exist.
And we create the _IN_GENRE_ relationships.

Execute this code: in the sandbox on the right.

[source,Cypher]
----
:auto USING PERIODIC COMMIT
LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing/2-movieData.csv'
AS row
MERGE (m:Movie {movieId: row.movieId})
ON CREATE SET
m.tmdbId = row.tmdbId,
m.imdbId = row.movie_imdbId,
m.imdbRating = toFloat(row.imdbRating),
m.released = row.released,
m.title = row.title,
m.year = toInteger(row.year),
m.poster = row.movie_poster,
m.runtime = toInteger(row.runtime),
m.countries = split(coalesce(row.countries,""), "|") ,
m.imdbVotes = toInteger(row.imdbVotes),
m.revenue = toInteger(row.revenue),
m.plot = row.plot,
m.url = row.movie_url,
m.budget = toInteger(row.budget),
m.languages = split(coalesce(row.languages,""), "|")
with m,  split(coalesce(row.genres,""), "|")  as genres
UNWIND genres AS genre
WITH m, genre
MERGE (g:Genre {name:genre})
MERGE (m)-[:IN_GENRE]->(g)
----

When you execute this code you should see:

Added 5566 labels, created 5566 nodes, set 78264 properties, created 11916 relationships

== Step 2: Importing actor data

This is the Cypher code for second pass we will make through the 2-movieData.csv file to create the _Person_ nodes for actors.
Notice in this code we perform all of the necessary transformations of types when we set the properties for the _Person_ node.
We use `MERGE` to only create the _Person_ nodes if they do not already exist. We also set the _Actor_ label and create the _ACTED_IN_ relationships and set the _role_ property for the relationship.

Execute this code in the sandbox on the right.

[source,Cypher,role=nocopy noplay]
----
:auto USING PERIODIC COMMIT
LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing/2-movieData.csv'
AS row
WITH row WHERE row.work = "ACTED_IN"
MERGE (p:Person {tmdbId: row.person_tmdbId})
ON CREATE SET
p.imdbId = row.person_imdbId,
p.bornIn = row.bornIn,
p.name = row.name,
p.bio = row.bio,
p.poster = row.person_poster,
p.url = row.person_url,
p.born = CASE row.born WHEN "" THEN null ELSE date(row.born) END
WITH row, p
SET p.died = CASE row.died WHEN "" THEN null ELSE date(row.died) END
WITH row, p
MATCH (m:Movie {movieId: row.movieId})
MERGE (p)-[r:ACTED_IN]->(m)
SET p:Actor
SET r.role = row.role
----

When you execute this code, you should see:

Added 18984 labels, created 9486 nodes, set 93369 properties, created 22057 relationships

== Step 3: Importing director data

This is the Cypher code for third pass we will make through the 2-movieData.csv file to create the _Person_ nodes for directors.
Notice in this code we perform all of the necessary transformations of types when we set the properties for the _Person_ node.
We use `MERGE` to only create the _Person_ nodes if they do not already exist. We also set the _Director_ label and create the _DIRECTED_ relationships.

Execute this code in the sandbox on the right.

[source,Cypher,role=nocopy noplay]
----
:auto USING PERIODIC COMMIT
LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing/2-movieData.csv'
AS row
WITH row WHERE row.work = "DIRECTED"
MERGE (p:Person {tmdbId: row.person_tmdbId})
ON CREATE SET
p.imdbId = row.person_imdbId,
p.bornIn = row.bornIn,
p.name = row.name,
p.bio = row.bio,
p.poster = row.person_poster,
p.url = row.person_url,
p.born = CASE row.born WHEN "" THEN null ELSE date(row.born) END
WITH row, p
SET p.died = CASE row.died WHEN "" THEN null ELSE date(row.died) END
WITH row, p
MATCH (m:Movie {movieId: row.movieId})
MERGE (p)-[:DIRECTED]->(m)
SET p:Director
----

When you execute this code, you should see:

Added 4620 labels, created 2180 nodes, set 16310 properties, created 6001 relationships,

== Step 4: Importing the User data

The *2-ratingData.csv* file is much simpler to process.
Notice in this code we perform all of the necessary transformations of types when we set the properties for the _Person_ node.
We use `MERGE` to only create the _Person_ nodes if they do not already exist. We also set the _Director_ label and create the _DIRECTED_ relationships.

Execute this code in the sandbox on the right.

[source,Cypher,role=nocopy noplay]
----
:auto USING PERIODIC COMMIT
LOAD CSV WITH HEADERS
FROM 'https://data.neo4j.com/importing/2-ratingData.csv'
AS row
MATCH (m:Movie {movieId: row.movieId})
MERGE (u:User {userId: row.userId})
ON CREATE SET u.name = row.name
MERGE (u)-[r:RATED]->(m)
ON CREATE SET r.rating = toInteger(row.rating),
r.timestamp = toInteger(row.timestamp)
----

When you execute this code, you should see:

Added 111 labels, created 111 nodes, set 81367 properties, created 81145 relationships

include::./questions/verify.adoc[leveloffset=+1]

[.summary]
== Summary

In this challenge, you transformed the multi-value string data to list (StringArray) types to match our target data model.

This concludes your introduction to importing CSV data into Neo4j.

