= Basic Cypher queries
:type: quiz
:sandbox: true

//[.video]
//video::ImKvXY72SA0[youtube,width=560,height=315]

[.transcript]
== Basic filtering

In the course, link:/courses/cypher-fundamentals[Cypher Fundamentals^], you learned some basic querying where you use the `WHERE` clause to filter queries where you test equality.

Execute this query:
[source,cypher]
----
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = 'Tom Hanks' AND m.year = 2013
RETURN m.title
----

In this query, we find all Person nodes with the name, Tom Hanks. We then traverse the ACTED_IN relationships to all Movie nodes that have a year property equal to 2013.
We are specifying the pattern, and we are filtering what we retrieve in that pattern where we test equality.
We then return the three movie titles that satisfy the query.

You can also test inequality:

[source,cypher]
----
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name <> 'Tom Hanks' AND m.title = 'Captain Phillips'
RETURN p.name
----

This query returns the names of all actors that acted in the movie, Captain Phillips where Tom Hanks is excluded.
It returns the names of the three actors that satisfy the filtering criteria.

We can also use OR to expand the filtering to return more data as follows:

[source,cypher]
----
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)
WHERE p.name = 'Tom Hanks' OR m.title = 'Captain Phillips'
RETURN p.name, m.title
----

This query returns rows containing the name and title. Each row represents an actor who acted in Captain Phillips or has the name of Tom Hanks.
In this result you will see multiple rows for Tom Hanks and each movie he acted in.
You will also see multiple rows for each of the actors who acted in the movie, Captain Phillips.

Later in this course you will learn how to group data that is returned so that there are not multiple rows for Tom Hanks or multiple rows for the movie, Captain Phillips.

=== String matching

When the property is a string type, you can filter by the starting characters in the string:

[source,cypher]
----
MATCH (m:Movie)
WHERE  m.title STARTS WITH 'Toy Story'
RETURN m.title, m.released
----

This query returns the four title and released dates for all movies whose title begins with Toy Story.

And you can filter queries whose properties end with a set of characters:

[source,cypher]
----
MATCH (m:Movie)
WHERE  m.title ENDS WITH ' I'
RETURN m.title, m.released
----

This query returns five rows that meet the filtering criteria.

Additionally, you can test if a substring is contained in a property:

[source,cypher]
----
MATCH (m:Movie)
WHERE  m.title CONTAINS 'River'
RETURN m.title, m.released
----

Due to the type of index present in the graph, ENDS WITH and CONTAINS queries do not use the index to retrieve the data. Managing indexes is beyond the scope of this course, but you can read about indexes here[https://neo4j.com/docs/cypher-manual/current/indexes-for-search-performance/#administration-indexes-types^]

=== Case of strings for matching

String matching in Cypher is case-sensitive. If string values could be mis-interpreted if the letters do not match in case, your queries may miss data in the graph.
For example, the use may enter a mixed-case value, emil@Neo4j.com, which is not the same for matching purposes to emil@neo4j.com.

Here is an example query where case is significant:

[source,cypher]
----
MATCH (p:Person)
WHERE toLower(p.name) ENDS WITH 'demille'
RETURN p.name
----

We do not know if the data in the graph for a name is DeMille, Demille, or deMlle.
To ensure we match all Person nodes that could be one of these we transform the property value to lower-case so we can perform the test.
This query returns one name, Cecille B. DeMille.

Conversely, we can do the same test with upper-case:

[source,cypher]
----
MATCH (p:Person)
WHERE toUpper(p.name) ENDS WITH 'DEMILLE'
RETURN p.name
----

This query returns the same name.

=== Testing null property values

A property for a node or relationship is null if it does not exist.
You can test the existence of a property for a node as follows:

[source,cypher]
----
MATCH (p:Person)
WHERE p.died IS NOT NULL AND p.born.year >= 1985
RETURN p.name, p.born, p.died
----

This query returns the names, born, and died properties for all people who have a value for their died property and who were born after 1985.
In this graph, it returns 6 rows.

And we can test if a property exists:

[source,cypher]
----
MATCH (p:Person)
WHERE p.died IS NULL AND p.born.year <= 1922
RETURN p.name, p.born, p.died
----

This query returns all people born before 1923 who do not have a died property value.
It returns 21 rows for our dataset.

=== Testing labels or patterns?

Depending on your data model, it may be useful to test the label a node has. This is particularly useful when a node may have multiple labels.
Here is how you test labels:

[source,cypher]
----
MATCH (p:Person)
WHERE p:Actor AND p:Director AND p.name STARTS WITH 'Tom'
RETURN p.name, labels(p)
----

This query will retrieve all Person nodes with the label Actor and Director that have a name that starts with Tom.
It returns the name of the 11 people and their labels.

Here is a variation of the previous query.
Rather than using the Actor or Director labels, it uses the relationship to the movie which imply the labels in the graph:

[source,cypher]
----
MATCH (p:Person)-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-(p)
WHERE  p.name STARTS WITH 'Tom'
RETURN p.name, labels(p), m.title
----

This query retrieves all people whose name begins with Tom, who acted in a movie and who also directed the same movie.
This query is more specific in that the same person both directed and acted in the movie.
In the previous query, we were only looking at labels and not relationships to movies.
This query returns 12 rows, but notice that some people directed and acted in multiple movies.

=== Testing list inclusion

You can test if a value is in a list property:

[source,cypher]
----
MATCH (m:Movie)
WHERE "Israel" IN m.countries
RETURN m.title, m.languages, m.countries
----

This query returns the titles, languages, countries of all movies that have Israel in their list of countries.
It returns 8 rows.

== Check your understanding

include::questions/1-complete-query.adoc[leveloffset=+1]
include::questions/2-answer-question.adoc[leveloffset=+1]

[.summary]
== Summary

In this lesson, reviewed and learned about basic query filtering using the `WHERE` clause.
In the next challenge, you will write queries to filter data
