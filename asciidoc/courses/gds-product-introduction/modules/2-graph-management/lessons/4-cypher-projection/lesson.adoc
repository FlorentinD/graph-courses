= Cypher Projections
:type: quiz

// [.video]
// video::xxxx[youtube,width=560,height=315]


[.transcript]
== Introduction

While the native projection is easier, its filtering and aggregation capabilities aren’t as flexible as Cypher. The Cypher projection, as its name implies, uses Cypher to define the projection pattern, and as such, enables more flexibility.

Whether Cypher or native projection is faster, depends on your query. Its easiest to compare the two against your use-case.

In this lesson, we will go over the cypher projection syntax, an applied example, where cypher projections are useful, and common strategies for transition from Cypher to native projections as workflows mature.

=== Syntax

A Cypher projection takes 2 mandatory arguments: `graphName` and `sourceNode`. 
The third parameter is `targetNode` and is usually provided.
The parameter is optional and can be `null` to project an unconnected node.
The next and fourth optional `dataConfig` parameter can be used to project node properties and labels as well as relationship properties and type.
The last and fifth optional `configuration` parameter can be used for general configuration of the projection such as `readConcurrency`.

[opts="header",cols="1,1,8"]
|===
| Name              | Optional | Description
| graphName         | no       | The name under which the graph is stored in the catalog.
| sourceNode        | no       | The source node of the relationship. Must not be null.
| targetNode        | yes      | The target node of the relationship. The targetNode can be null (for example due to an `OPTIONAL MATCH`), in which case the source node is projected as an unconnected node.
| dataConfig        | yes      | Properties and labels configuration for the source and target nodes as well as properties and type configuration for the relationship.
| configuration     | yes      | Additional parameters to configure the projection.
|===

=== Applied Example

In the last lesson we answered which actors were most prolific based on the number of movies they acted in. Suppose instead we wanted to know which actors are the most influential in terms of the number of other actors they have been in recent, high grossing, movies with.

For the sake of this example, we will call a movie “recent” if it was released on or after 1990, and high-grossing if it had revenue >= $1M.

The graph is not set up to answer this question well with a direct native projection. However, we can use a cypher projection to filter to the appropriate nodes and perform an aggregation to create an `ACTED_WITH` relationship that has a `actedWithCount` property going directly between actor nodes.

[source, cypher]
----
MATCH (a1:Actor)-[:ACTED_IN]->(m:Movie)<-[:ACTED_IN]-(a2)
WHERE m.year >= 1990 AND m.revenue >= 1000000
RETURN gds.graph.project(
  'proj-cypher',
  a1,
  a2,
  {
    sourceLabels: labels(a1),
    targetLabels: labels(a2),,
    relationshipType: 'ACTED_WITH',
    relationshipProperties: {actedWithCount: count(*)}
  }
);
----

Once that is done we can apply degree centrality like we did last lesson. Except we will weight the degree centrality by `actedWithCount` property and also directly stream the top 10 results back.  This counts how many times the actor has acted with other actors in recent, high grossing movies.

[source, cypher]
----
CALL gds.degree.stream('proj-cypher',{relationshipWeightProperty: 'actedWithCount'})
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, score
ORDER BY score DESC LIMIT 10
----

The results include some big name actors as we would expect.

[options="header"]
|===========================
| name               | score
| Robert De Niro     | 123.0
| Bruce Willis       | 120.0
| Johnny Depp        | 102.0
| Denzel Washington  | 99.0
| Nicolas Cage       | 90.0
| Julianne Moore     | 87.0
| Brad Pitt          | 87.0
| Samuel L. Jackson  | 85.0
| George Clooney     | 84.0
| Morgan Freeman     | 84.0
|===========================


=== Flexibility of Cypher Projections

In the above example, there were two things that prevented us from directly using a native projection. They also happen to be two of the most common cases for using Cypher Projections.

. *Complex Filtering:* Using node and/or relationship property conditions or other more complex MATCH/WHERE conditions to filter the graph, rather than just node label and relationship types.
. *Aggregating Multi-Hop Paths with Weights:* The relationship projection required aggregating the `(Actor)-[ACTED_IN]-(Movie)-[ACTED_IN]-(Actor)` pattern to a `(Actor)-[ACTED_WITH {actedWithCount}]-(Actor)` pattern where the `actedWithCount` is a relationship weight property. This type of projection, where we need to transform multi-hop paths into an aggregated relationship that connects the source and target node, is a commonly occurring pattern in graph analytics.

Further options enabled by Cypher projections include merging different node labels and relationship types and defining virtual relationships between nodes based on property conditions or other query logic.

=== Check your understanding

include::questions/1-graph-projection-using-cypher.adoc[leveloffset=+1]

include::questions/2-cypher-projection-use-cases.adoc[leveloffset=+1]

include::questions/3-cypher-projection-usage.adoc[leveloffset=+1]



[.summary]
== Summary

In this lesson we learned about Cypher projections. What they are, how and when to use them.

In the next lesson, you will be challenged to create your own Cypher projection.