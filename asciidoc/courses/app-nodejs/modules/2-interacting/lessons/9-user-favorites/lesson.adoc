= My Favorites List
:type: challenge

image::images/movie-cards.png[Add a Movie to your Favorites, role=right]

The website features a **My Favorites** list which allows users to create a list of their favorite movies.
When a logged in user hovers their mouse over a Movie on the website, a bookmark icon appears in the top right hand corner.
Clicking this icon will either add or remove the movie from the user's Favorites list.

All of the user's favorite movies are then listed at http://localhost:3000/favorites.


When a user clicks the bookmark icon for the first time, a `POST` request is sent to the `/api/favorites/{id}` endpoint.


When a `POST` request it sent to the API, the following will happen:

1. The server directs the request to the route handler in `src/routes/account.routes.js`, which verifies the user's JWT token before handling the request
2. The route handler creates an instance of the `FavoriteService` in `src/services/favorites.service.js`.
3. The `add` method is then called on the `FavoriteService` instance with the ID taken from the JWT token, and the ID of the movie that has been extracted from the request URL.
4. It is then the responsibility of the `FavoriteService` to persist this information and format a response.

Likewise, when it is clicked for a movie that has already been favorited, a `DELETE` request is sent to the same URL to remove.

== Saving the Relationship

In order to save this information to the database, we will have to modify the `FavoriteService` to run a cypher statement in a **write** transaction, creating a `:HAS_FAVORITE` relationship from the User to the Movie.

The `add` method in the `FavoriteService` currently returns some dummy data.

.src/services/favorite.service.js
[source,js]
----
async add(userId, movieId) {
    // TODO: Open Session
    // TODO: Create HAS_FAVORITE relationship
    // TODO: Return movie details and `favorite` property

    return {
        ...goodfellas,
        favorite: true,
    }
}
----

We will update this method to create a session, then run a Write Transaction with a unit of work to find the User and Movie by their IDs and then create the relationship between them.
Finally, we will close the session and return the movie information.

The UI expects a `favorite` property to be returned which is used to update the state of the movie card.


Let's first open a new session from `this.driver`.

[source,js]
----
// Open a new session
const session = this.driver.session()
----

Then run the Cypher query to `MERGE` a relationship between the `:User` and `:Movie` nodes, before returning all properties for the movie plus the


[source,js]
----
// Create HAS_FAVORITE relationship within a Write Transaction
const res = await session.writeTransaction(tx => tx.run(`
    MATCH (u:User {userId: $userId})
    MATCH (m:Movie {tmdbId: $movieId})

    MERGE (u)-[r:HAS_FAVORITE]->(m)
    ON CREATE SET u.createdAt = datetime()

    RETURN m {
        .*,
        favorite: true
    } AS movie
`, { userId, movieId }))
----

If no records are returned, either the `:User` and `:Movie` cannot be found.
In which case, we should return a 404 error.

[source,js]
----
// Throw an error if the user or movie could not be found
if ( res.records.length === 0 ) {
    throw new NotFoundError(`Couldn't create a favorite relationship for User ${userId} and Movie ${movieId}`)
}
----

Then, we should close the session.

[source,js]
----
// Close the session
await session.close()
----

Finally, we should return the `movie` value from the first row of the Cypher query.

[source,js]
----
return toNativeTypes(res.records[0].get('movie'))
----


=== Working Solution

[%collapsible]
.Click here to reveal the completed `add` method
====

.src/services/favorite.service.js
[source,js]
----
async add(userId, movieId) {
    // Open a new session
    const session = this.driver.session()

    // Create HAS_FAVORITE relationship within a Write Transaction
    const res = await session.writeTransaction(tx => tx.run(`
        MATCH (u:User {userId: $userId})
        MATCH (m:Movie {tmdbId: $movieId})

        MERGE (u)-[r:HAS_FAVORITE]->(m)
        ON CREATE SET u.createdAt = datetime()

        RETURN m {
            .*,
            favorite: true
        } AS movie
    `, { userId, movieId }))

    // Close the session
    await session.close()

    // Throw an error if the user or movie could not be found
    if ( res.records.length === 0 ) {
        throw new NotFoundError(`Couldn't create a favorite relationship for User ${userId} and Movie ${movieId}`)
    }

    return toNativeTypes(res.records[0].get('movie'))
}
----
====


== Deleting the Relationship

The code for deleting the `:HAS_FAVORITE` relationship will be similar, only the Cypher statement will really change.

Instead of two seaprate `MATCH` clauses, we can instead attempt to find the pattern within a single clause.
If the relationship (with an alias of `r`) exists, we will delete it and then return the movie information with `favorite` set to `false`.

[source,cypher]
----
MATCH (u:User {userId: $userId})-[r:HAS_FAVORITE]->(m:Movie {tmdbId: $movieId})
DELETE r

RETURN m {
    .*,
    favorite: true
} AS movie
----

=== Working Solution

[%collapsible]
.Click here to reveal the completed `remove` method
====

.src/services/favorite.service.js
[source,js]
----
async remove(userId, movieId) {
    // Open a new session
    const session = this.driver.session()

    // Delete HAS_FAVORITE relationship within a Write Transaction
    const res = await session.writeTransaction(tx => tx.run(`
        MATCH (u:User {userId: $userId})-[r:HAS_FAVORITE]->(m:Movie {tmdbId: $movieId})
        DELETE r

        RETURN m {
            .*,
            favorite: false
        } AS movie
    `, { userId, movieId }))

    // Close the session
    await session.close()

    // Throw an error if the user or movie could not be found
    if ( res.records.length === 0 ) {
        throw new NotFoundError(`Couldn't delete the favorite relationship for User ${userId} and Movie ${movieId}`)
    }

    return toNativeTypes(res.records[0].get('movie'))
}
----
====

== Listing a User's favorite movies

The `FavoriteService` also has an `all` method which should return a paginated list of the User's favorite movies.
At the moment it is hardcoded to return a list of movies.

We will update this method to open a new session and then follow the `(:User)-[:FAVORITED_MOVIE]->(:Movie)` pattern to retrieve a list of movies.


.src/services/favorite.service.js
[source,js]
----
async all(userId, orderBy = 'title', order = 'ASC', limit = 6, skip = 0) {
    // TODO: Open a new session
    // TODO: Retrieve a list of movies favorited by the user
    // TODO: Close session

    return popular
}
----

To implement this function we must open a new session, and execute a read transaction with the following Cypher query:

[source,cypher]
----
MATCH (u:User {userId: $userId})-[r:HAS_FAVORITE]->(m:Movie)
RETURN m {
    .*,
    favorite: false
} AS movie
ORDER BY m.\`${orderBy}\` ${order}
SKIP $skip
LIMIT $limit
----

We have written similar code a few times already, so try to implement this one on your own.
If you get stuck, you can view the full solution below.

[%collapsible]
.Click here to reveal the completed `all` method
====

.src/services/favorite.service.js
[source,js]
----
async all(userId, orderBy = 'title', order = 'ASC', limit = 6, skip = 0) {
    // Open a new session
    const session = this.driver.session()

    // Retrieve a list of movies favorited by the user
    const res = await session.readTransaction(tx => tx.run(`
        MATCH (u:User {userId: $userId})-[r:HAS_FAVORITE]->(m:Movie)
        RETURN m {
            .*,
            favorite: false
        } AS movie
        ORDER BY m.\`${orderBy}\` ${order}
        SKIP $skip
        LIMIT $limit
    `, { userId, skip: int(skip), limit: int(limit) }))

    // Close the session
    await session.close()

    return res.records.map(row => toNativeTypes(row.get('movie')))

    return popular
}
----
====



== Adding the `favorite` property to the `/movies/*` endpoints

In the queries above, we have hard coded the `favorite` property because we can guarantee the value as a result of the query above.
However, we will not be able to do this within the `MovieService`.

Instead, to determine this property we can use the open transaction to retrieve a list of ID's that the user has liked.
Then, in our second query we can check that the current ID of the current movie is contained within the `$favorites` parameter.

.src/services/movie.service.js
[source,js]
----
const res = await session.readTransaction(async tx => {
    const favorites = []

    // Find favorite movie IDs for the current user if defined
    if ( userId !== undefined ) {
        const favoriteResult = await tx.run(`
            MATCH (u:User {userId: $userId})-[:HAS_FAVORITE]->(m)
            RETURN m.tmdbId AS id
        `)
        favorites = favoriteResult.map(row => row.get('id'))
    }

    // Add a check to make sure the movie id is in our $favorites parameter
    return tx.run(`
        MATCH (m:Movie)
        WHERE exists(m.\`${orderBy}\`)
        RETURN m {
            .*,
            favorite: m.tmdbId IN $favorites
        } AS movie
        ORDER BY m.\`${orderBy}\` ${order}
        SKIP $skip
        LIMIT $limit
    `, { skip: int(skip), limit: int(limit), favorites }
    )
})
----




== Testing

To test that the My Favorites functionality has been correctly implemented, run the following command in a new terminal session:

[source,sh]
npm run test 07

If all tests pass then the favorite list functionality has been successfully implemented.

You can view the test file by opening `test/challenges/07-favorites-list.spec.js`.



include::./questions/verify.adoc[]


[.summary]
== Module Summary

In this module, we have used read and write transactions to interact with the data held in Neo4j.
We have also learned about some of the considerations that we need to make when working with the Cypher type system in our Node.js application.

In the *Project Backlog* module, we will implement the remaining missing pieces of functionality.
This isn't strictly required, but will be good practise for your development journey ahead.
