= Handling Driver Errors
:type: quiz
:branch: 04-handle-constraint-errors
:test-number: 04

This brings us on to the remaining `// TODO` comment in the `AuthService`.


== Unique User Email Addresses

We still have a hard-coded element in the query that will we need to implement.
Currently, if the email address passed to the method isn't `graphacademy@neo4j.com`, a `ValidationError` is thrown.

.src/services/auth.service.js
[source,js,indent=0]
----
include::{repository-raw}/main/src/services/auth.service.js[tag=constraintError]
----

This will seriously affect Neoflix's Daily Active Users numbers.

As all of the methods in the `AuthService` are `async` functions, we can use `try`/`catch` blocks to catch any errors as they are thrown.

We can pass the responsibility of handling the duplicate user error to the database by creating a Unique Constraint on the `:User` label, asserting that the `email` property must be unique.

This also gives us the added benefit of an indexed property that we can look up User nodes by email without a costly `NodeByLabelScan`.


=== Creating a Unique Constraint

To create a Unique Constraint against a label, we can a one-time query against the database.
If you want to learn more about indexes and constraints


[source,cypher]
----
include::{repository-raw}/main/cypher/2-interacting/6-unique-emails/constraint.cypher[]
----

Click the **Run in Sandbox** button to create the constraint on your Sandbox.


If we now run the following query in the Sandbox, a node should be created without any problems.

[source,cypher]
----
include::{repository-raw}/main/cypher/2-interacting/6-unique-emails/create-user.cypher[]
----

Running the query a second time should return the following error:

[source,rel=nocopy]
Node(33880) already exists with label `User` and property
 `email` = 'uniqueconstraint@example.com'

=== Catching the Error

We can wrap the entire method in a try/catch block and then use the error message to detect the error.

When a Neo4j Error is thrown, we can check the `code` property for a Neo4j specific code.
In this case, we're looking for a code of `Neo.ClientError.Schema.ConstraintValidationFailed`.
If the error is different, we should re-throw it so it can be handled by the application.

.Catching the error
[source,js,indent=0]
----
include::{repository-raw}/{branch}/src/services/auth.service.js[tag="catch"]
----

[TIP]
. ...and finally
You may also have noticed that the `session.close` call has been moved to the `finally` block.
This is to ensure that is is always closed regardless of whether the query was successful or an error was thrown.


== Working Solution

.Click here to reveal the updated `register` method.
[%collapsible]
====
[source,js,indent=0]
----
include::{repository-raw}/{branch}/src/services/auth.service.js[tag="register"]
----
====

// Testing

include::../../../../includes/test.adoc[]


== Check Your Understanding

include::./questions/1-error-code.adoc[]

include::./questions/2-error-details.adoc[]

[.summary]
== Lesson Summary

In this lesson, we have learned how to interpret the errors thrown by the Neo4j JavaScript Driver.
If we wanted to go further, we could use Regular Expression to extract more specific information about the `ConstraintValidationFailed` error.

Now that we are able to successfully register a user by their email address, let's update the `authenticate` method to find our user in the database.
