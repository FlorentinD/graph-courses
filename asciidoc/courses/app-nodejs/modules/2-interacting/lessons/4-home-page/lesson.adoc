= The Home Page
:type: challenge
:branch: 02-movie-lists
:test-number: 02

Now for another challenge.

In this challenge, you will use the knowledge gained so far in this course to add new functionality to the API.
You will need to modify the `all` method of the link:{repository-blob}main/src/routes/movie.services.js[`MovieService`^] to do the following:


1. <<Open a new Session>>
2. <<Execute a Cypher query within a new Read Transaction>>
3. <<Extract a list of Movies from the Result>>
4. <<Close the Session>>
5. <<Return the Results>>

Once you have completed the challenge, you will be asked to run a unit test to verify that the code has been correctly implemented.
If the test runs correctly, the title of the highest rated movie will be logged.
You will need this value to verify that the test has run correctly.


== Exploring the Code

Before you start, let's take a look at the code.
If you are not interested in the code, you can skip straight to <<Steps to Complete>>.

If you load up the app at http://localhost:3000, you will see two lists on the home page; one for Popular Movies and one for Latest Releases.
Both of these lists are populated by a request to link:http://localhost:3000/api/movies[`http://localhost:3000/api/movies`^] with some additional parameters.

=== Route Handler

You can find the route handler, the function that handles the request, in link:{repository-blob}main/src/routes/movies.routes.js[`src/routes/movies.routes.js`^]:

.src/routes/movies.routes.js
[source,js]
----
include::{repository-raw}/main/src/routes/movies.routes.js[tag=list]
----

Within the route handler, you can see that:

1. The `sort`, `order`, `limit` and `skip` values are extracted from the query string.  This allows us to apply sorting and pagination to the results.
2. A new instance of the `MovieService` is created with the Driver instance created in link:../../1-driver/3-connecting/[Adding the Driver] passed to the constructor.
3. The results are retreived via the `all` method and are returned by the handler as JSON.

=== The Movie Service

The magic happens in the `MovieService`, located at link:{repository-blob}main/src/services/movies.service.js[`src/services/movies.service.js`^].
For this route we are concerned with the `all` method.

If we take a closer look at the `add` method, we can see that it currently returns a hardcoded list of popular movies from a another file in the repository.

[source,js,indent=0]
.src/services/movie.service.js
----
include::{repository-raw}/main/src/services/movie.service.js[tag=all]
----

You will need to replace thesse `TODO` comments with working code to complete the challenge.


== Implementing Read Transactions

As we learned in the Sessions and Transactions lesson, you will need to open a new session, run the query within a Read Transaction.
Once the query has run, you will need to close the session.
Then, finally you will have to extract and return the results.


=== Open a new Session

Within the `all` method, first open a new session:

[source,js,indent=0]
----
include::{repository-raw}/main/example/index.js[tag=session]
----

=== Execute a Cypher query within a new Read Transaction

This session then provides us with a `readTransaction` method which we can pass a function to represent the unit of work.

The function will have one argument passed to it, a `Transaction` instance that we can use to execute a Cypher statement using the `run` method.
The `run` method accepts two arguments:

1. The Cypher query as a parameterised string
2. An object containing the values for the parameters prefixed in the query with a dollar sign (`$`)

[source,js,indent=0]
----
include::{repository-raw}/{branch}/src/services/movie.service.js[tag=allcypher]
----


[WARNING]
====
In the second argument, we use references to the `int` function imported from `neo4j-driver` to convert the skip and limit values into a Neo4j integer.
Remember to add the import statement to the top of the file.

[source,js]
----
include::{repository-raw}/main/example/integers.js[tag=import]
----
====


=== Extract a list of Movies from the Result

Now that we have a complete result assigned to the `res` variable, we can use the `map` function on the `res.records` array to retrieve the `movie` value returned by the query.

[source,js,indent=0]
----
include::{repository-raw}/{branch}/src/services/movie.service.js[tag=allmovies]
----


=== Close the Session

Then, finally, before returning anything, make sure that the session is closed.

[source,js,indent=0]
----
include::{repository-raw}/main/example/index.js[tag="session.close"]
----


=== Return the Results

Finally, update the `return` statement to return the `movies` list extracted above.

[source,js,indent=0]
----
include::{repository-raw}/{branch}/src/services/movie.service.js[tag=return]
----


== Working Solution

[%collapsible]
.Click here to reveal the completed `all` method
====

.src/services/movie.service.js
[source,js,indent=0]
----
include::{repository-raw}/{branch}/src/services/movie.service.js[tag=all]
----
====

include::../../../../includes/test.adoc[]


== Verifying the Test

include::./questions/verify.adoc[leveloffset=+1]


[.summary]
== Lesson Summary

In this lesson, you used your knowledge of sessions and transactions to retrieve a list of Movie nodes from the database.

In the next lesson, we will look at writing data to the database.
