= The Home Page
:type: challenge

If you load up the app at http://localhost:3000, you will see two lists on the home page; one for Popular Movies and one for Latest Releases.

Both of these lists are populated by a request to `http://localhost:3000/api/movies` with some additional parameters.
The route handler for this route is in `src/routes/movies.routes.js`.

// TODO: tag::movies.list[]

.src/routes/movies.routes.js
[source,js]
----

router.get('/', async (req, res) => {
    try {
        const { orderBy, order, limit, skip }
            = getPagination(req) // <1>

        const movieService = new MovieService(
            req.transaction
        ) // <2>

        const movies = await movieService.all(
            orderBy, order, limit, skip
        ) // <3>

        res.json(movies)
    }
    catch(e) {
        next(e)
    }
})
----

Within the above code block, you can see the following:

<1> The `orderBy`, `order`, `limit` and `skip` values are extracted from the query string.  This allows us to apply sorting and pagination to the results.
<2> A new instance of the `MovieService` is called with the transaction passed through to the constructor.  We will use this to send our Cypher query to Neo4j.
<3> The results are retreived via the `all` method and are returned by the handler as JSON.


== The Movie Service

The magic happens in the `MovieService`, located at `src/services/movie.service.js`.
For this route we are concerned with the `all` method.


== Implementing Read Transactions

As we learned in the Sessions and Transactions lesson, we can call the `readTransaction` method with a function to represent the unit of work.


If we take a look in `src/services/movie.service.js`, the `add` method on the `MovieService` currently returns a list of popular movies from a another file in the repository.

[source,js]
.src/services/movie.service.js
----
async all(orderBy = 'title', order = 'ASC', limit = 6, skip = 0, userId = undefined) {
    // TODO: Open an Session
    // TODO: Execute a query in a new Read Transaction
    // TODO: Get a list of Movies from the Result
    // TODO: Close the session

    return popular
}
----

We will now rewrite this method to query Neo4j and return the results.

=== 1. Open an Session

First, we will want to open a new session.

[source,js]
----
const session = this.driver.session()
----

=== 2. Execute a query in a new Read Transaction

This session then provides us with a `readTransaction` method which we can pass a function to represent the unit of work.

The function will accept one argument, a `Transaction` instance that we can use to execute a Cypher statement using the `run` method.

The `run` method accepts two arguments:

1. The Cypher query as a parameterised string
2. An object containing the values for the parameters prefixed in the query with a dollar sign (`$`)


[source,js]
----
const res = await session.readTransaction(tx => tx.run(`
    MATCH (m:Movie)
    WHERE exists(m.\`${orderBy}\`)
    RETURN m { .* } AS movie
    ORDER BY m.\`${orderBy}\` ${order}
    SKIP $skip
    LIMIT $limit
`, { skip: int(skip), limit: int(limit) }))
----

[NOTE]
In the second argument, we use references to the `int` function imported from `neo4j-driver`.
We will cover this in more detail in the **Cypher Type System** and **Rating Movies** lessons.


=== 3. Get a list of Movies from the Result

Now that we have results held in the `res` variable, we can use the `map` function on the `res.records` array to retrieve the `movie` value returned by the query.

[source,js]
----
const movies = res.records.map(row => toNativeTypes(row.get('movie')))
----


=== 4. Close the session

Then, finally, before returning anything, we should make sure that the session is closed.

[source,js]
----
await session.close()
----


== Working Solution

[%collapsible]
.Click here to reveal the completed `all` method
====

.src/services/movie.service.js
[source,js]
----
async all(orderBy = 'title', order = 'ASC', limit = 6, skip = 0, userId = undefined) {
    // Open an Session
    const session = this.driver.session()

    // Execute a query in a new Read Transaction
    const res = await session.readTransaction(tx => tx.run(`
        MATCH (m:Movie)
        WHERE exists(m.\`${orderBy}\`)
        RETURN m { .* } AS movie
        ORDER BY m.\`${orderBy}\` ${order}
        SKIP $skip
        LIMIT $limit
    `, { skip: int(skip), limit: int(limit) }))

    // Get a list of Movies from the Result
    const movies = res.records.map(row => toNativeTypes(row.get('movie')))

    // Close the session
    await session.close()

    return movies
}
----

====

== Testing

To test that this function correctly calls Neo4j, run the following command in a new terminal session:

[source,sh]
npm run test 02


The test file is located at `test/challenges/02-movie-lists.spec.js`.


== Verifying the Test

include::./questions/verify.adoc[]


[.summary]
== Lesson Summary

In this lesson, we learned how to execute a Cypher statement within a Read Transaction.

In the next lesson, we will look at writing data to the database.
