= Handling Driver Errors
:type: quiz
:branch: 6-unique-emails


In the Promise API, a `run` function will return a Promise that rejects if an error occurs.
This could be a transient error, for example a problem connecting to the database, or something  more permanent, for example a Syntax Error or a Constraint Error.

Below are examples of how to catch an error while using `async`/`await` and the Promise API.

[.tab]
.Using async/await
====
When using `async`/`await`, you will need to use `try` and `catch` blocks to catch any errors.

.Async Example
[source,js,subs="attributes+",indent=0]
----
include::{repository-raw}/main/example/catch-errors.js[tag=catch]
----

====

[.tab]
.Using Promises
====
When using `Promises`, you will need to add a `catch` function to catch any errors.

.Using Promises
[source,js,subs="attributes+",indent=0]
----
include::{repository-raw}/main/example/catch-errors.js[tag=promise]
----


====

== Neo4j Errors

If the Neo4j JavaScript Driver does throw an error at any point during its lifecycle, the error will be an instance of a link:https://neo4j.com/docs/api/javascript-driver/current/class/lib6/error.js~Neo4jError.html[`Neo4jError`^].

The `Neo4jError` class extends the native JavaScript `Error`, and as such contains a `message` property.
This will always contain detailed information on the error.

The `Neo4jError` also includes a `code` property, which provides a higher level information about the query.

Some interesting include:

* `Neo.ClientError.Procedure.ProcedureCallFailed` - Failed to invoke a procedure. See the detailed error description for exact cause.
* `Neo.ClientError.Schema.ConstraintViolation` - Added or changed index entry would violate constraint.
* `Neo.ClientError.Security.Forbidden` - An attempt was made to perform an unauthorized action.
* `Neo.ClientError.Security.Unauthorized` - The client is unauthorized due to authentication failure.
* `Neo.ClientError.Statement.ParameterMissing` - The statement refers to a parameter that was not provided in the request.
* `Neo.ClientError.Statement.SyntaxError` - The statement contains invalid or unsupported syntax.
* `Neo.TransientError.General.TransactionMemoryLimit` - There is not enough memory to perform the current task.


For a comprehensive list of status codes, see link:https://neo4j.com/docs/status-codes/current/[Status Codes in the Neo4j Documentation^].





// == Query Errors

// First, let's take a look at how we can catch an error thrown while running a query.
// If you prefer, you can skip to <<Catching Errors>>.


// When an error is thrown,


// [source,rel=nocopy]
// Node(33880) already exists with label `User` and property
//  `email` = 'uniqueconstraint@example.com'

// === Catching the Error

// We can wrap the entire method in a try/catch block and then use the error message to detect the error.

// When a Neo4j Error is thrown, we can check the `code` property for a Neo4j specific code.
// In this case, we're looking for a code of `Neo.ClientError.Schema.ConstraintValidationFailed`.
// If the error is different, we should re-throw it so it can be handled by the application.




// == Catching Errors

// In order to correctly


// === Create a Unique Constraint

// In order to ensure that a property and label combination is unique, we will need to run a `CREATE CONSTRAINT` query.
// In this case, we would need to ensure that the `email` property is unique across all nodes with a `:User` label.

// Click the **Run in Sandbox** button to create the constraint on your Sandbox.

// [source,cypher]
// ----
// include::{repository-raw}/main/cypher/2-interacting/6-unique-emails/constraint.cypher[]
// ----




// == Add a Try/Catch Block


// == Modify the Register Method





// This will seriously affect Neoflix's Daily Active Users numbers.

// As the `register` method is an `async` function, we will need to use a `try`/`catch` block to catch any errors as they are thrown.



// === Unique User Email Addresses





// As all of the methods in the `AuthService` are `async` functions, we can use

// We can pass the responsibility of handling the duplicate user error to the database by creating a Unique Constraint on the `:User` label, asserting that the `email` property must be unique.

// This also gives us the added benefit of an indexed property that we can look up User nodes by email without a costly `NodeByLabelScan`.


// == Catching Errors

// === Create a Unique Constraint

// === Modify the Register Method

// Currently, if the email address passed to the method isn't `graphacademy@neo4j.com`, a `ValidationError` is thrown.

// .src/services/auth.service.js
// [source,js,indent=0]
// ----
// include::{repository-raw}/main/src/services/auth.service.js[tag=constraintError]
// ----

// == --


// To create a Unique Constraint against a label, we can a one-time query against the database.
// If you want to learn more about indexes and constraints





// If we now run the following query in the Sandbox, a node should be created without any problems.

// [source,cypher]
// ----
// include::{repository-raw}/main/cypher/2-interacting/6-unique-emails/create-user.cypher[]
// ----

// Running the query a second time should return the following error:

// [source,rel=nocopy]
// Node(33880) already exists with label `User` and property
//  `email` = 'uniqueconstraint@example.com'

// === Catching the Error

// We can wrap the entire method in a try/catch block and then use the error message to detect the error.

// When a Neo4j Error is thrown, we can check the `code` property for a Neo4j specific code.
// In this case, we're looking for a code of `Neo.ClientError.Schema.ConstraintValidationFailed`.
// If the error is different, we should re-throw it so it can be handled by the application.

// .Catching the error
// [source,js,indent=0]
// ----
// include::{repository-raw}/{branch}/src/services/auth.service.js[tag="catch"]
// ----

// [TIP]
// . ...and finally
// You may also have noticed that the `session.close` call has been moved to the `finally` block.
// This is to ensure that is is always closed regardless of whether the query was successful or an error was thrown.


// == Working Solution

// .Click here to reveal the updated `register` method.
// [%collapsible]
// ====
// [source,js,indent=0]
// ----
// include::{repository-raw}/{branch}/src/services/auth.service.js[tag="register"]
// ----
// ====

// // Testing

// include::../../../../includes/test.adoc[]


== Check Your Understanding

include::./questions/1-error-code.adoc[leveloffset=+1]

include::./questions/2-error-details.adoc[leveloffset=+1]

[.summary]
== Lesson Summary

In this lesson, we have learned how to interpret the errors thrown by the Neo4j JavaScript Driver.

In the next challenge, we will add a unique constraint to the database and add a `try`/`catch` block the `register` method to handle the error thrown when the email address is already taken.

// If we wanted to go further, we could use Regular Expression to extract more specific information about the `ConstraintValidationFailed` error.

// Now that we are able to successfully register a user by their email address, let's update the `authenticate` method to find our user in the database.
