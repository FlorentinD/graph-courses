= Movie Lists and Pagination
:type: challenge
:test-number: 11
:branch: 11-movie-lists

In this challenge, we will implement the remaining methods for retrieving a list of movies:

* `getByGenre` - should return a paginated list of movies that are listed in a particular Genre
* `getForActor` - should return a paginated list of movies that a particular Person has acted in
* `getForDirector` - should return a paginated list of movies that a particular Person has directed

These methods are very similar to the `all()` method which returns a full list, but with a different pattern in the `MATCH` clause.

// .src/services/movie.service.js
// [source,js,indent=0]
// ----
// include::{repository-raw}/10-genre-details/src/services/movie.service.js[tag=all]
// ----

We can take the `all()` method and simply modify the pattern in the first line of the Cypher query to provide a different route.

In the following subtasks, the pattern will be listed along with any additional parameters that need to be added to the second argument of the `tx.run` call.



== getByGenre

**Pattern:** `MATCH (m:Movie)-[:IN_GENRE]->(:Genre {name:$name})`

**Additional Parameter:** `name` - The name of the movie

[%collapsible]
.Click to reveal the completed `getByGenre()` method
====

Find the `getByGenre()` method in `src/services/movie.service.js` and modify the function to find a list of movies by Genre.

.src/services/movie.service.js
[source,js,indent=0]
----
include::{repository-raw}/{branch}/src/services/movie.service.js[tag=getByGenre]
----

// .src/services/movie.service.js
// [source,js]
// ----
// async getByGenre(name, orderBy = 'title', order = 'ASC', limit = 6, skip = 0, userId = undefined) {
//     // Open an Session
//     const session = this.driver.session()

//     // Execute a query in a new Read Transaction
//     const res = await session.readTransaction(async tx => {
//         const favorites = []
//         if ( userId !== undefined ) {
//             const favoriteResult = await tx.run(`MATCH (u:User {userId: $userId})-[:HAS_FAVORITE]->(m) RETURN m.tmdbId AS id`)
//             favorites = favoriteResult.map(row => row.get('id'))
//         }

//         return tx.run(`
//             MATCH (m:Movie)-[:IN_GENRE]->(:Genre {name: $name})
//             WHERE exists(m.\`${orderBy}\`)
//             RETURN m {
//                 .*,
//                 favorite: m.tmdbId IN $favorites
//             } AS movie
//             ORDER BY m.\`${orderBy}\` ${order}
//             SKIP $skip
//             LIMIT $limit
//         `, { name, skip: int(skip), limit: int(limit), favorites }
//         )
//     })

//     // Get a list of Movies from the Result
//     const movies = res.records.map(row => toNativeTypes(row.get('movie')))

//     // Close the session
//     await session.close()

//     return movies
// }
// ----

====



== getForActor

Find the `getForActor()` method in `src/services/movie.service.js` and modify the function to find a list of movies by Actor.

**Pattern:** `MATCH (:Person {tmdbId: $id})-[:ACTED_IN]->(m:Movie)`

**Additional Parameter:** `id` - The `tmdbId` property relating to the Person

[%collapsible]
.Click to reveal the completed `getForActor()` method
====

.src/services/movie.service.js
[source,js,indent=0]
----
include::{repository-raw}/{branch}/src/services/movie.service.js[tag=getForActor]
----

// .src/services/movie.service.js
// [source,js]
// ----
// async getForActor(id, orderBy = 'title', order = 'ASC', limit = 6, skip = 0, userId = undefined) {
//     // Open an Session
//     const session = this.driver.session()

//     // Execute a query in a new Read Transaction
//     const res = await session.readTransaction(async tx => {
//         const favorites = []
//         if ( userId !== undefined ) {
//             const favoriteResult = await tx.run(`MATCH (u:User {userId: $userId})-[:HAS_FAVORITE]->(m) RETURN m.tmdbId AS id`)
//             favorites = favoriteResult.map(row => row.get('id'))
//         }

//         return tx.run(`
//             MATCH (:Person {tmdbId: $id})-[:ACTED_IN]->(m:Movie)
//             WHERE exists(m.\`${orderBy}\`)
//             RETURN m {
//                 .*,
//                 favorite: m.tmdbId IN $favorites
//             } AS movie
//             ORDER BY m.\`${orderBy}\` ${order}
//             SKIP $skip
//             LIMIT $limit
//         `, { id, skip: int(skip), limit: int(limit), favorites }
//         )
//     })

//     // Get a list of Movies from the Result
//     const movies = res.records.map(row => toNativeTypes(row.get('movie')))

//     // Close the session
//     await session.close()

//     return movies
// }
// ----

====

== getForDirector

Find the `getForDirector()` method in `src/services/movie.service.js` and modify the function to find a list of movies by Director.

**Pattern:** `MATCH (:Person {tmdbId: $id})-[:DIRECTED]->(m:Movie)`

**Additional Parameter:** `id` - The `tmdbId` property relating to the Person

[%collapsible]
.Click to reveal the completed `getForDirector()` method
====

.src/services/movie.service.js
[source,js,indent=0]
----
include::{repository-raw}/{branch}/src/services/movie.service.js[tag=getForDirector]
----

// .src/services/movie.service.js
// [source,js]
// ----
// async getForDirector(id, orderBy = 'title', order = 'ASC', limit = 6, skip = 0, userId = undefined) {
//     // Open an Session
//     const session = this.driver.session()

//     // Execute a query in a new Read Transaction
//     const res = await session.readTransaction(async tx => {
//         const favorites = []
//         if ( userId !== undefined ) {
//             const favoriteResult = await tx.run(`MATCH (u:User {userId: $userId})-[:HAS_FAVORITE]->(m) RETURN m.tmdbId AS id`)
//             favorites = favoriteResult.map(row => row.get('id'))
//         }

//         return tx.run(`
//             MATCH (:Person {tmdbId: $id})-[:DIRECTED]->(m:Movie)
//             WHERE exists(m.\`${orderBy}\`)
//             RETURN m {
//                 .*,
//                 favorite: m.tmdbId IN $favorites
//             } AS movie
//             ORDER BY m.\`${orderBy}\` ${order}
//             SKIP $skip
//             LIMIT $limit
//         `, { id, skip: int(skip), limit: int(limit), favorites }
//         )
//     })

//     // Get a list of Movies from the Result
//     const movies = res.records.map(row => toNativeTypes(row.get('movie')))

//     // Close the session
//     await session.close()

//     return movies
// }
// ----

====

// Testing
include::../../../../includes/test.adoc[]


== Verifying the Test

include::./questions/1-coppola-films.adoc[]


[.summary]
== Lesson Summary

In this lesson, we looked at how we could modify an existing function to discover movies related to another node.

If you wished to go further, you could refactor the code to provide a single method that took the additional pattern as a parameter.

In the next lesson, we will implement the `findById` method.
