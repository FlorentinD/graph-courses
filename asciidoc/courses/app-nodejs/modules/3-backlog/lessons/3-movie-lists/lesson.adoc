= Movie Lists and Pagination
:type: challenge
:test-number: 10
:test-filename: 10-movie-lists.spec.js

Inside the `MovieService` there are a few methods for retrieving lists of movies:

* `getByGenre` - Will return a paginated list of movies that are listed in a particular Genre
* `getForActor` - Will return a paginated list of movies that a particular Person has acted in
* `getForDirector` - Will return a paginated list of movies that a particular Person has directed

All of these methods are very similar to the `all` method which returns a full list, but with a different pattern.

For example, where the `all` method will attempt to find all nodes with a `:Movie` label, the `getByGenre` method will follow a pattern of `(:Genre {name: $name})<-[:IN_GENRE]-(m)`.
Some may also require an additional parameter to be added to the second argument of `tx.run`.

We can copy and paste the method already used in the `all` method and update the pattern:

== getByGenre

**Pattern:** `MATCH (m:Movie)-[:_IN_GENRE]->(:Genre {name:$ name})`

**Additional Parameter:** `name` - The name of the movie

[%collapsible]
.Click to reveal the completed `getByGenre` method
====

Find the `getByGenre` method in `src/services/movie.service.js` and modify the function to find a list of movies by Genre.

.src/services/movie.service.js
[source,js]
----
async getByGenre(name, orderBy = 'title', order = 'ASC', limit = 6, skip = 0, userId = undefined) {
    // Open an Session
    const session = this.driver.session()

    // Execute a query in a new Read Transaction
    const res = await session.readTransaction(async tx => {
        const favorites = []
        if ( userId !== undefined ) {
            const favoriteResult = await tx.run(`MATCH (u:User {userId: $userId})-[:HAS_FAVORITE]->(m) RETURN m.tmdbId AS id`)
            favorites = favoriteResult.map(row => row.get('id'))
        }

        return tx.run(`
            MATCH (m:Movie)-[:IN_GENRE]->(:Genre {name: $name})
            WHERE exists(m.\`${orderBy}\`)
            RETURN m {
                .*,
                favorite: m.tmdbId IN $favorites
            } AS movie
            ORDER BY m.\`${orderBy}\` ${order}
            SKIP $skip
            LIMIT $limit
        `, { name, skip: int(skip), limit: int(limit), favorites }
        )
    })

    // Get a list of Movies from the Result
    const movies = res.records.map(row => toNativeTypes(row.get('movie')))

    // Close the session
    await session.close()

    return movies
}
----

====



== getByActor

Find the `getByActor` method in `src/services/movie.service.js` and modify the function to find a list of movies by Actor.

**Pattern:** `MATCH (:Person {tmdbId: $id})-[:ACTED_IN]->(m:Movie)`

**Additional Parameter:** `id` - The `tmdbId` property relating to the Person

[%collapsible]
.Click to reveal the completed `getByActor` method
====

.src/services/movie.service.js
[source,js]
----
async getForActor(id, orderBy = 'title', order = 'ASC', limit = 6, skip = 0, userId = undefined) {
    // Open an Session
    const session = this.driver.session()

    // Execute a query in a new Read Transaction
    const res = await session.readTransaction(async tx => {
        const favorites = []
        if ( userId !== undefined ) {
            const favoriteResult = await tx.run(`MATCH (u:User {userId: $userId})-[:HAS_FAVORITE]->(m) RETURN m.tmdbId AS id`)
            favorites = favoriteResult.map(row => row.get('id'))
        }

        return tx.run(`
            MATCH (:Person {tmdbId: $id})-[:ACTED_IN]->(m:Movie)
            WHERE exists(m.\`${orderBy}\`)
            RETURN m {
                .*,
                favorite: m.tmdbId IN $favorites
            } AS movie
            ORDER BY m.\`${orderBy}\` ${order}
            SKIP $skip
            LIMIT $limit
        `, { id, skip: int(skip), limit: int(limit), favorites }
        )
    })

    // Get a list of Movies from the Result
    const movies = res.records.map(row => toNativeTypes(row.get('movie')))

    // Close the session
    await session.close()

    return movies
}
----

====

== getByDirector

Find the `getByDirector` method in `src/services/movie.service.js` and modify the function to find a list of movies by Director.

**Pattern:** `MATCH (:Person {tmdbId: $id})-[:DIRECTED]->(m:Movie)`

**Additional Parameter:** `id` - The `tmdbId` property relating to the Person

[%collapsible]
.Click to reveal the completed `getByDirector` method
====

.src/services/movie.service.js
[source,js]
----
async getForDirector(id, orderBy = 'title', order = 'ASC', limit = 6, skip = 0, userId = undefined) {
    // Open an Session
    const session = this.driver.session()

    // Execute a query in a new Read Transaction
    const res = await session.readTransaction(async tx => {
        const favorites = []
        if ( userId !== undefined ) {
            const favoriteResult = await tx.run(`MATCH (u:User {userId: $userId})-[:HAS_FAVORITE]->(m) RETURN m.tmdbId AS id`)
            favorites = favoriteResult.map(row => row.get('id'))
        }

        return tx.run(`
            MATCH (:Person {tmdbId: $id})-[:DIRECTED]->(m:Movie)
            WHERE exists(m.\`${orderBy}\`)
            RETURN m {
                .*,
                favorite: m.tmdbId IN $favorites
            } AS movie
            ORDER BY m.\`${orderBy}\` ${order}
            SKIP $skip
            LIMIT $limit
        `, { id, skip: int(skip), limit: int(limit), favorites }
        )
    })

    // Get a list of Movies from the Result
    const movies = res.records.map(row => toNativeTypes(row.get('movie')))

    // Close the session
    await session.close()

    return movies
}
----

====


// Testing
include::../../../../includes/code.adoc[tag="test"]


== Verifying the Test

include::./questions/1-coppola-films.adoc[]


[.summary]
== Lesson Summary

In this lesson, we looked at how we could modify an existing function to discover movies related to another node.

If you wished to go further, you could refactor the code to provide a single method that took the additional pattern as a parameter.

In the next lesson, we will implement the `findById` method.

// In this lesson, we modified the `find` method to retrieve basic genre information from the Neo4j database.

// In the next lesson, we will look at the methods in the `MovieService` that we use to populate lists of movies in the UI.
