= Movie Details
:type: challenge
:test-number: 11
:test-filename: 11-movie-details.spec.js

If you click on any movie, you'll see that the API currently only returns information about the film Goodfellas.

The page itself is populated by three API calls:

1. The details about the movie are loaded via the `api/movies/{id}` endpoint.  This endpoint populates the information in the header along with the list of directors and actors.
2. The similar movies list is loaded by a call to the `api/movies/{id}/similar` endpoint.
3. The ratings on the right hand side of the page are loaded by a call to the `api/movies/{id}/ratings` endpoint.


== Movie Details

The movie details are retrieved by the `findById` method on the `MovieService` in `src/services/movie.service.js`.

.src/services/movie.service.js
[source,js]
----
async findById(id, userId = undefined) {
    // TODO: Find a movie by its ID

    return goodfellas
}
----

Most of the important information is held as properties on the Movie node, but the payload should also return some additional information.
We can use the `size` function to get a count of ratings for the movie and use a link:https://neo4j.com/docs/cypher-manual/current/syntax/lists/#cypher-pattern-comprehension[Pattern Comprehension] to get a list of actors and directors.

As with the other movie methods in the `MovieService`, we should also provide a `favorite` value to represent whether the user has added this movie to their My Favorites list or not.

Here is the Cypher query:

.Movie Details
[source,cypher]
----
MATCH (m:Movie {tmdbId: $id})
RETURN m {
    .*,
    actors: [ (a)-[r:ACTED_IN]->(m) | a { .*, role: r.role } ],
    directors: [ (d)-[:DIRECTED]->(m) | d { .* } ],
    genres: [ (m)-[:IN_GENRE]->(g) | g { .name }],
    favorite: m.tmdbId IN $favorites
} AS movie
LIMIT 1
----

We should also throw a `NotFound` error if the query returns no records.

Update the `findById` method to retrieve the movie details from the database.

[%collapsible]
.Click to reveal the completed `findById` method
====

.src/services/movie.service.js
[source,js]
----
async findById(id, userId = undefined) {
    // Open a new database session
    const session = this.driver.session()

    // Find a movie by its ID
    const res = await session.readTransaction(async tx => {
        const favorites = []
        if ( userId !== undefined ) {
            const favoriteResult = await tx.run(`MATCH (u:User {userId: $userId})-[:HAS_FAVORITE]->(m) RETURN m.tmdbId AS id`)
            favorites = favoriteResult.map(row => row.get('id'))
        }

        return tx.run(`
            MATCH (m:Movie {tmdbId: $id})
            RETURN m {
                .*,
                actors: [ (a)-[r:ACTED_IN]->(m) | a { .*, role: r.role } ],
                directors: [ (d)-[:DIRECTED]->(m) | d { .* } ],
                genres: [ (m)-[:IN_GENRE]->(g) | g { .name }],
                ratingCount: size((m)<-[:RATED]-()),
                favorite: m.tmdbId IN $favorites
            } AS movie
            LIMIT 1
        `, { id, favorites }
        )
    })

    // Close the session
    await session.close()

    // Throw a 404 if the Movie cannot be found
    if ( res.records.length === 0 ) {
        throw new NotFoundError(`Could not find a Movie with tmdbId ${id}`)
    }

    const [ first ] = res.records

    return toNativeTypes(first.get('movie'))
}
----

====





// [%collapsible]
// .Click to reveal the an example JSON payload
// ====
// .Example Movie
// [source,json]
// ----
// {

//   "imdbRating": 8.7,
//   "languages": [
//     "English",
//     "Italian"
//   ],
//   "tmdbId": "769",
//   "title": "Goodfellas",
//   "poster": "https://image.tmdb.org/t/p/w440_and_h660_face/oErEczcVUmJm0EPdvWsvK4g4Lv3.jpg",
//   "plot": "Henry Hill and his friends work their way up through the mob hierarchy.",
//   "year": 1990,
//   "runtime": 146,
//   "actors": [
//     {
//       "name": "Robert De Niro",
//       "bornIn": "Greenwich Village, New York City, New York, USA",
//       "tmdbId": "0000134",
//       "poster": "https://image.tmdb.org/t/p/w440_and_h660_face/cT8htcckIuyI1Lqwt1CvD02ynTh.jpg",
//       "born": "1943-08-17"
//     }
//   ],
//   "directors": [
//     {
//       "name": "Martin Scorsese",
//       "bornIn": "Queens, New York, USA",
//       "tmdbId": "0000217",
//       "poster": "https://image.tmdb.org/t/p/w440_and_h660_face/9U9Y5GQuWX3EZy39B8nkk4NY01S.jpg",
//       "born": "1942-11-17"
//     }
//   ],
//   "genres": [
//     {
//       "link": "/genres/Crime",
//       "name": "Crime"
//     },
//     {
//       "link": "/genres/Drama",
//       "name": "Drama"
//     }
//   ],
//   "ratingCount": 124,
//   "favorite": true
// }
// ----
// ====


== Similar Movies

Similar movies are retrieved using the `getSimilarMovies` method.


To provide a simple set of similar movies, we can use the number of neighbours in common and their IMDB rating to generate a similarity score.

.Find Similar Movies
[source,cypher]
----
MATCH (:Movie {tmdbId: $id})-[:IN_GENRE|ACTED_IN|DIRECTED]->()<-[:IN_GENRE|ACTED_IN|DIRECTED]-(m)
WHERE exists(m.imdbRating)

WITH m, count(*) AS inCommon
ORDER BY inCommon DESC, m.imdbRating DESC

SKIP $skip
LIMIT $limit

RETURN m {
    .*,
    score: m.imdbRating * inCommon,
    favorite: m.tmdbId IN $favorites
} AS movie
----

Update the `getSimilarMovies` method to return similar movies from the database.


[%collapsible]
.Click here to reveal the completed `getSimilarMovies` method
====

[source,js]
----
async getSimilarMovies(id, limit = 6, skip = 0, userId = undefined) {
    // Open an Session
    const session = this.driver.session()

    // Get similar movies based on genres or ratings
    const res = await session.readTransaction(async tx => {
        const favorites = []
        if ( userId !== undefined ) {
            const favoriteResult = await tx.run(`MATCH (u:User {userId: $userId})-[:HAS_FAVORITE]->(m) RETURN m.tmdbId AS id`)
            favorites = favoriteResult.map(row => row.get('id'))
        }

        return tx.run(`
            MATCH (:Movie {tmdbId: $id})-[:IN_GENRE|ACTED_IN|DIRECTED]->()<-[:IN_GENRE|ACTED_IN|DIRECTED]-(m)
            WHERE exists(m.imdbRating)

            WITH m, count(*) AS inCommon
            ORDER BY inCommon DESC, m.imdbRating DESC

            SKIP $skip
            LIMIT $limit

            RETURN m {
                .*,
                score: m.imdbRating * inCommon,
                favorite: m.tmdbId IN $favorites
            } AS movie
        `, { id, skip: int(skip), limit: int(limit), favorites }
        )
    })


    // Get a list of Movies from the Result
    const movies = res.records.map(row => toNativeTypes(row.get('movie')))

    // Close the session
    await session.close()

    return movies
}
----

====


// Testing
include::../../../../includes/code.adoc[tag="test"]

== Verifying the Test

include::./questions/1-most-similar-movie.adoc[]


[.summary]
== Lesson Summary

In this lesson, we modified the `findById` method to return movie details from the Neo4j database.

In the next lesson, we will finish off the Movie page by populating the list of reviews from Neo4j.
