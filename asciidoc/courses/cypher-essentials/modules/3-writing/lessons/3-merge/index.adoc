= Merging Data
:order: 3

We can use the `MERGE` keyword to merge data into the database.

`MERGE` operations works by first trying to find a pattern in the database.
If the pattern is found then the data is returned.
If the pattern is not found, then the data will be created.

Let's look at some examples.

== Merging Nodes

Merging data allows us to run two operations inside a single query.
Neo4j will check for the existence and only create if the data doesn't exist.

If we take the query from the previous lesson.

[source,cypher]
MERGE (p:Person {name: "Daniel Kaluuya"})
RETURN p

Changing the `CREATE` statement to `MERGE` will mean that only a single `:Person` node will be created to represent **Daniel Kaluuya**.
So we can run this statement multiple times without worrying about multiple nodes.

== Merging Nodes with Multiple Properties

There is the tendency to chain multiple properties into the same pattern.

[source,cypher]
MERGE (p:Person {name: "Daniel Kaluuya", createdAt: datetime()})
RETURN p

However, if we run this statement multiple times we will get multiple nodes.  Why is that?

Well, we're trying to find a Node with the name **Daniel Kaluuya** and a createdAt timestamp set to the current time.
If the run the same query more than once, the _entire_ pattern won't be found and therefore a new node will be created.

Say we try to add a constraint on the `:Person` label and `name` property.
Neo4j will try to **create** a new node, as one doesn't already exist with the same `createdAt` value.

Instead, we can se the `ON CREATE SET`, `ON MATCH SET` or `SET` keywords to set any additional properties.

[source,cypher]
----
// Find or create a person with this name
MERGE (p:Person {name: "Daniel Kaluuya"})

// Only set the `createdAt` property if the node is created during this query
ON CREATE SET p.createdAt = datetime()

// Only set the `updatedAt` property if the node was created previously
ON MATCH SET p.updatedAt = datetime()

// Set the `born` property regardless
SET p.born = 1989
----


== Merging Relationships

Relationships can also be tricky.

Say we want to create a Movie node to represent **Judas and the Black Messiah**.
We could write the following query:

[source,cypher]
----
// Find or create a person with this name
MERGE (p:Person {name: "Daniel Kaluuya"})-[:ACTED_IN]->(m:Movie {title: "Judas and the Black Messiah"})
----

What will happen now?

1. Neo4j will attempt to find a Person node with the name **Daniel Kaluuya**.
2. Then, it will attempt to expand the `:ACTED_IN` relationships
3. For the nodes at the other end of the relationship, it will check for

In the current database state, we have the `:Person` node *but we don't have* the `:Movie` node.
So Neo4j will attempt to create the entire pattern; first creating a new `:Person` node, then the `:Movie` node, before creating the relationship between.

This will cause an error to be thrown telling us that the unique constraint would be voilated by this query:

[source]
Node(77) already exists with label `Person` and property `name` = 'Daniel Kaluuya'


Instead, we should break down the query into three parts.  First merge the `:Person` node, then the `:Movie`, then the `:ACTED_IN` relationship between the two.

[source,cypher]
----
// Find or create a person with this name
MERGE (p:Person {name: "Daniel Kaluuya"})

// Find or create a movie with this title
MERGE (m:Movie {title: "Judas and the Black Messiah"})

// Find or create a relationship between the two nodes
MERGE (p)-[:ACTED_IN]->(m)
----


== Combining `MATCH` and `MERGE`

As we've discussed previously, it is good practice to perform any read operations before write operations. `[why?]`


[source,cypher]
----
// MATCH the nodes
MATCH (p:Person {name: "Daniel Kaluuya"})
MATCH (m:Movie {title: "Judas and the Black Messiah"})

// Before the MERGE operation
MERGE (p)-[:ACTED_IN]->(m)
----

Otherwise we will need to put a  `WITH` between.
`[more explanation]`

[source,cypher]
----
MERGE (p:Person {name: "Daniel Kaluuya"})

WITH p
MATCH (m:Movie {title: "Judas and the Black Messiah"})

MERGE (p)-[:ACTED_IN]->(m)
----


input::read[type=button,class=btn,value=Mark as Read]