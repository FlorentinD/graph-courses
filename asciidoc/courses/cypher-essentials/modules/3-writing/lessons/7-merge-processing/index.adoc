= Merging Processing
:order: 7

You have learned that you can use `MERGE` to create nodes and relationships in the graph.
`MERGE` operations work by first trying to find a pattern in the graph.
If the pattern is found then the data already exists and is not created.
If the pattern is not found, then the data can be created.

== Customizing `MERGE` behavior

You can also specify behavior at runtime that enables you to set properties when the node is created or when the node is found.
We can use the `ON CREATE SET`, `ON MATCH SET` or `SET` keywords to set any additional properties.

In this example, if the _Person_ node for _McKenna Grace_ does not exist, it is created and the _createdAt_ property is set.
If the node is found, then the _updatedAt_ property is set.
In both cases, the _born_ property is set.

Run this Cypher code at least 2 times to observe what properties are set.

[source,cypher]
----
// Find or create a person with this name
MERGE (p:Person {name: 'McKenna Grace'})

// Only set the `createdAt` property if the node is created during this query
ON CREATE SET p.createdAt = datetime()

// Only set the `updatedAt` property if the node was created previously
ON MATCH SET p.updatedAt = datetime()

// Set the `born` property regardless
SET p.born = 2006

RETURN p
----

== Merging Relationships

Relationships can also be tricky.

Say we want to create a _Movie_ node to represent the movie, _Judas and the Black Messiah_.
We might write the following query.

Try running this Cypher code which will produce an error:

[source,cypher]
----
MERGE (p:Person {name: 'Daniel Kaluuya'})-[:ACTED_IN]->(m:Movie {title: 'Judas and the Black Messiah'})
RETURN p, m
----

Here is what happens in the query processor:

1. Neo4j will attempt to find a _Person_ node with the name _Daniel Kaluuya_.
2. Then, it will attempt to expand the _ACTED_IN_ relationships in the graph.
3. For the nodes at the other end of the relationship, it will check for the _Daniel Kaluuya_ node.

In the current database state, we have the _Person_ node *but we don't have* the _Movie_ node.
So Neo4j will attempt to create the entire pattern; first creating a new _Person_ node, then the _Movie_ node, before creating the relationship between.

This will cause an error to be thrown telling us that the unique constraint would be violated by this query.

Instead, we can break down the query into three parts.  First merge the _Person_ node, then the _Movie_, then the _ACTED_IN_ relationship between the two.

[source,cypher]
----
// Find or create a person with this name
MERGE (p:Person {name: 'Daniel Kaluuya'})

// Find or create a movie with this title
MERGE (m:Movie {title: 'Judas and the Black Messiah'})

// Find or create a relationship between the two nodes
MERGE (p)-[:ACTED_IN]->(m)
----

This code creates the _Movie_ node and the relationship.


== Check your understanding

include::questions/1-what-merge-does.adoc[]

include::questions/2-complete-code.adoc[]


//input::read[type=button,class=btn,value=Mark as Read]