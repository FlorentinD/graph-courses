= More Art than Query Language
:type: quiz
:order: 1


[TIP]
.Our goal:
As a *Movie fanatic* +
I would like to *Find my favorite actor* +
So that I can *find out more about him*

== What is Cypher?
Cypher is a query language designed for graphs.

The whiteboard model is stored in the database as a graph.

When we draw a graph on paper or the whiteboard, we represent it as circles connected together using arrows.

image::images/Whiteboard.png[Whiteboardh,width=600,align=center]

Just as we would draw circles and arrows on a piece of paper, we write out the pattern in Cypher:

* Nodes are represented by parentheses `()`
* We use a colon to signify the label(s), for example `(:Person)`
* Relationships between nodes are written with two dashes, for example `(:Person)--(:Movie)`
* The direction of a relationship is indicated using a greater than or less than symbol `<` or `>` , for example `(:Person)-->(:Movie)`
* The type of the relationship is written using the square brackets between the two dashes: `[` and `]`, for example `[:ACTED_IN]`
* Properties are drawn in a _speech bubble_ in a JSON like syntax.
  * Properties in Neo4j are key/value pairs

== How Cypher works

Cypher works by matching patterns in the data.
We do this using the `MATCH` keyword.
You can think of the `MATCH` keyword as similar to the `FROM` clause in an SQL statement.

For example, if we want to find a Person in the graph, we would `MATCH` a pattern of a single node with a label of `:Person` - prefixed with a colon (`:`)

[source,cypher,role=nocopy,norun]
----
MATCH (:Person)
// incomplete MATCH statement, need to return something
----

Suppose we want to retrieve all Person nodes from the graph. We can assign a variable by placing a value before the colon.
Let's use the variable `p`. Now that p represents all nodes retrieved from the graph, we can return them using the `RETURN` clause.

[TIP]
Try hitting the **Run Query** button to see the results.

Run this Cypher code:

[source,cypher]
----
MATCH (p:Person)
RETURN p
----

This query returns all nodes in the graph with the _Person_ label.

Now, say we want to find the node which represents the person who's name is  _Tom Hanks_.
Our `:Person` nodes all have a name property.
We can use the __braces__ to specify the key/value pair of `name` and `Tom Hanks`.
As _Tom Hanks_ is a string, we will need to place it inside single or double quotes.

Run this Cypher code:

[source,cypher]
----
MATCH (p:Person {name: 'Tom Hanks'})
RETURN p
----

This query returns a single node that represents _Tom Hanks_.
In the graph view of Neo4j Browser, the node is visualized as a bubble.
You can also view the results returned in table view where you can view the properties of the node

We can access properties using a _dot notation_, for example to return the `name` property we would use `p.name`.

Run this query:

[source,cypher]
----
MATCH (p:Person {name: 'Tom Hanks'})
RETURN p.name
----

This query returns the value of the _name_ property of the _Tom Hanks_ node.

Another way that you can filter queries is by using the `WHERE` clause, rather than specifying the property value inline.

This query is the same as the following query.

Run this query:

[source,cypher]
----
MATCH (p:Person)
WHERE p.name = 'Tom Hanks'
RETURN p.name
----

As you gain more experience with Cypher, you will find that using `WHERE` to filter you queries is very powerful because you can add more logic to your `WHERE` clause.
Here is an example:

Run this query:

[source,cypher]
----
MATCH (p:Person)
WHERE p.name = 'Tom Hanks' OR p.name = 'Rita Wilson'
RETURN p.name
----

This query returns two nodes.

// | p.name |
// | -- |
// | Tom Hanks |

== Check your understanding

include::questions/valid-clauses.adoc[]

include::questions/read-clause.adoc[]

include::questions/return-clause.adoc[]

