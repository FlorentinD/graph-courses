= Finding Relationships
:type: quiz
:order: 3


[TIP]
.Our Goal
As a *Movie fanatic* +
I would like to *Find movies for a particular actor* +
So that I can *Watch a movie this evening*


In the previous lesson, we used the `MATCH` clause to find the node in our database that represented _Tom Hanks_.

Run this Cypher code:

[source,cypher]
----
MATCH (p:Person {name: "Tom Hanks"})
RETURN p
----

We can extend the pattern in the match clause to _traverse_ through all relationships with a type of `ACTED_IN` to any node.
Our domain model shows that the _ACTED_IN_ relationship goes in an outgoing direction from the Person so we can add the direction in our pattern.
We often refer to this as a *traversal*.

[source,cypher,role=nocopy,norun]
----
//incomplete code
MATCH (p:Person {name: "Tom Hanks"})-[:ACTED_IN]->()
----

Our data model dictates that the node at the other end of that relationship will be _Movie_ node, so we don't necessarily need to specify the `:Movie` label in the node - instead we will use the variable `m`.

Run this Cypher code:

[source,cypher]
----
MATCH (p:Person {name: "Tom Hanks"})-[:ACTED_IN]->(m)
RETURN m.title
----

It returns the titles of all moves that _Tom Hanks_ acted in.

If we had multiple _types_ of nodes at the end of the `:ACTED_IN`relationship in our graph, we could make sure that we only return movies.

Run this Cypher code:

[source,cypher]
----
MATCH (p:Person {name: "Tom Hanks"})-[:ACTED_IN]->(m:Movie)
RETURN m.title
----

Because our graph only has _Movie_ nodes that have incoming _ACTED_IN_ relationships, this query returns the exact same results as the previous query.

== Check your understanding

include::questions/1-complete-query.adoc[]

include::questions/2-directors.adoc[]

