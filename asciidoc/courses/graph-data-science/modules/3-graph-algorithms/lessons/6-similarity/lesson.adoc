= Similarity
:type: quiz

[.transcript]
== Introduction
Similarity algorithms, as the name implies, are used to infer similarity between pairs of nodes. In GDS these algorithms run over the graph projection in bulk. When similar node pairs are identified according to the user specified metric and threshold, a relationship with a similarity score property is drawn between the pair.  Depending on which execution mode is used when running the algorithm, these similarity relationships can be streamed, mutated to the in-memory graph, or written back to the database.

Common use cases for similarity include:

* *Fraud detection:* finding potential fraud user accounts by analyzing how similar a set of new user accounts is to flagged accounts
* *Recommendation Systems:* In an online retail store, identify items that pair to the one currently being viewed by a user to inform impressions and increase rate of purchase
* *Entity Resolution*: Identify nodes that are similar to one another based on activity otr identifying information in the graph

=== Similarity Algorithms in GDS
GDS has two primary similarity algorithms:

* *Node Similarity*: Determines similarity between nodes based on the relative proportion of shared neighboring nodes in the graph. Node Similarity is a good choice where explainable is important, and you can narrow down the universe of comparisons to a subset of your data. Examples of narrowing down include focusing on just single communities, newly added nodes, or nodes within a specific proximity to a subgraph of interest.

* *K-Nearest Neighbor (KNN):* Determines similarity based off node properties.  The GDS KNN implementation can scale well for global inference over large graphs when tuned appropriately. it can be used in conjunction with embeddings and other graph algorithms to determine the similarity between nodes based on proximity in the graph, node properties, community structure, importance/centrality, etc.

=== Choice of Similarity Metric
Both Node Similarity and KNN provide choices between different similarity metrics. Node Similarity has choices between jaccard and overlap similarity. KNN choice of metric is driven by the node property types. list of integers are subject to jaccard and overlap, list of floating point numbers to cosine similarity, pearson, and euclidean. Using different metrics will of course alter the similarity score and change the interpretation slightly. You can read more about the different metrics for Node Similairty here[] and for KNN here[].


=== Controlling Scope of Comparisons
Comparing every node to every other node in the graph is a computationally expensive task of roughly `O(n^2)` complexity. The GDS implementations for both Node Similarity and KNN have internal mechanisms to intelligently select node pairs for comparison allowing them to work faster and scale better. They also have parameters that can be adjusted by the user to tune how node pairs are sampled and selected for comparison.

Node Similarity has a `degreeCutoof` for nodes which allows you to select a lower limit on nodes to be selected.

KNN has various parameters that can be tuned to effect the speed vs completeness trade-off of node comparisons.

=== Controlling Scope of Results


=== Applied Example with KNN
Let's take the embeddings we calculated on actors from the previous example and use it to determine similarity between the actors based on movies they have acted and or directed. If you do not have the graph projection from the previous node embeddings lesson saved you can regenerate the embeddings with the below code:


=== Similarity Functions
In addition to the node similarity and KNN algorithms, GDS also provides a set of functions that can be used to calculate similarity between two arrays of numbers using various similarity metrics including jaccard, overlap, Pearson, cosine  similarity and a few others.  The full documentation can be found https://neo4j.com/docs/graph-data-science/current/algorithms/similarity-functions/[here]. These functions are useful when you are interested in measuring similarity between a single select node pair at a time as opposed to calculating similarity over the entire graph.

== Check your Understanding


[.summary]
== Summary
