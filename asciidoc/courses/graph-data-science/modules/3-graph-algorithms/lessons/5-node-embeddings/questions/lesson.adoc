= Community Detection
:type: quiz

[.transcript]
== Introduction
Community detection algorithms are used to evaluate how groups of nodes may be clustered or partitioned in the graph.  Much of the community detection functionality in GDS is focused on distinguishing and assigning ids to these node groups for downstream analytics, visualization, or other processing.

Common use cases of community detection include:

* *Fraud detection*: Finding fraud rings by identifying accounts that have frequent suspicious transactions and/or share identifiers between one another.
* *Customer 360*: Disambiguating multiple records and interactions into a single customer profile so an organization has an aggregated source of truth for each customer.
* *Market segmentation*: dividing a target market into approachable subgroups based on priorities, behaviors, interests, and other criteria.

=== Louvain Community Detection
image::images/louvain-modularity.png[float="right", title="Louvain Modularity Optimization",width=500]
A common community detection algorithm is Louvain. Louvain maximizes a modularity score for each community, where the modularity quantifies the quality of an assignment of nodes to communities. This means evaluating how much more densely connected the nodes within a community are, compared to how connected they would be in a random network. Louvain optimizes this modularity with hierarchical clustering approach that recursively merges communities together. There are multiple parameters that can be used to tune Louvain to control its performance and the number and size of communities produced.  We will not cover them in depth here, but they are important to consider when applying Louvain to your use case. This includes the maximum number of iterations and hierarchical levels to use as well as the tolerance parameter for assessing convergence/stopping condition. This is fully covered in the https://neo4j.com/docs/graph-data-science/current/algorithms/louvain/[Louvain documentation].

An additional important thing to consider is that Louvain is a stochastic algorithm.  As such, the community assignments may change a bit when re-run. When the graph does not have a naturally well-defined community structure the changes between runs can be more significant. Louvain includes a `seedProperty` parameter which can be used to assign initial community ids and help with consistency between runs.

Other community detection algorithms, such as Weakly Connected Components (WWC) take a more deterministic partitioning approach to assigning communities and thus will not change significantly between runs.

'''

Below is an example of running Louvain to understand communities of actors and directors in our movies recommendations graph.

First create a graph projection with movies, actors, and directors. Project the relationships with an `UNDIRECTED` orientation as that works best with the Louvain algorithm.
[source,cypher]
----
CALL gds.graph.drop('proj');
CALL gds.graph.project('proj', ['Movie', 'Person'], {
    ACTED_IN:{orientation:'UNDIRECTED'},
    DIRECTED:{orientation:'UNDIRECTED'}
});
----

Then we can run Louvain.  In this case we will stream the results and display the count of actors by community id. I am setting the `maxLevel` parameter to 5 (10 is the default) to
[source,cypher]
----
CALL gds.louvain.stream('proj', {maxLevels:5, maxIterations:100})
YIELD nodeId, communityId
WITH gds.util.asNode(nodeId) AS n, communityId
WHERE n:Person
RETURN communityId, count(n) AS communitySize
ORDER BY communitySize DESC
----
\You can see that we get a few
== Check your understanding


[.summary]
== Summary
