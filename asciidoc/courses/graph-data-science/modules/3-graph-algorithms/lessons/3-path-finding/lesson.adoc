= Path Finding
:type: quiz


[.transcript]
== Introduction
Path finding algorithms find the shortest path between two or more nodes or evaluate the availability and quality of paths.

Common use cases of path finding are:

* *Supply chain analytics*: Identifying the fastest path between an origin and a destination or between a raw material and a finished product
* *Customer Journey*: Analyzing the events that make up a customer's experience. In healthcare for example, this can be the experience of an in-patient from admission to discharge.

=== Dijkstra Source-Target Shortest Path
A common, industry standard, similarity algorithm is dijkstra. It computes the shortest path between a source and a target node. Like many other path finding algorithms in GDS, dijkstra supports weighted relationships to account for distance or another cost property when comparing paths.

Below is an example of using dijkstra source-target shortest path to find the shortest path between the actors "Kevin Bacon" and "Denzel Washington".

First, confirm we have the two actor names right and that they are present in the graph. This will give us the node ids we need as input to  dijkstra shortest path.
[source,cypher]
----
MATCH(a:Actor)
WHERE a.name IN ['Kevin Bacon', 'Denzel Washington']
RETURN a.name, id(a)
----

Next, create the graph projection.
[source,cypher]
----
// include to clean up if there is a previous 'proj' graph
CALL gds.graph.drop('proj');
//projection of persons acting and/or directing movies
CALL gds.graph.project('proj',
    ['Person','Movie'],
    {
        ACTED_IN:{orientation:'UNDIRECTED'},
        DIRECTED:{orientation:'UNDIRECTED'}
    }
);
----

Then we can run dijkstra's shortest path.
[source,cypher]
----
CALL gds.shortestPath.dijkstra.stream('proj', {sourceNode:14487, TargetNode:16395})
YIELD index, sourceNode, targetNode, path
RETURN index,
    gds.util.asNode(sourceNode).name AS sourceNodeName,
    gds.util.asNode(targetNode).name AS targetNodeName,
    nodes(path) as path
ORDER BY index;
----

This should give you a 4 hop path between Kevin Bacon and Denzel Washington.


=== Other Path Finding Algorithms
Other GDS production tier Path Finding algorithms can be split into a few different subcategories they are listed below:

Shortest path between _two_ nodes

* *Apass:[* ] Shortest Path:* An extension of Dijkstra that uses a heuristic function to speed up computation.
* *Yenâ€™s Algorithm Shortest Path:* An extension of Dijkstra that allows you to find multiple, the top _k_, shortest paths,

Shortest path between a source node and multiple other target nodes

* *Dijkstra Single-Source Shortest Path:* Dijkstra implementation for shortest path between one source and multiple targets.
* *Delta-Stepping Single-Source Shortest Path:* Parallelized shortest path computation. Computes faster than dijkstra single-source shortest Path but uses more memory.

General path search between a source node and multiple other target nodes

* *Breadth First Search:* Searches paths in order of increasing distance from the source node on each iteration.
* *Depth First Search:* Searches as far as possible along a single multi-hop path on each iteration.


A full list of centrality algorithms across all project tiers can be found in the https://neo4j.com/docs/graph-data-science/current/algorithms/pathfinding/[GDS documentation].

== Check your understanding


[.summary]
== Summary
In this lesson you learned about path finding in GDS. We went over common use cases and how to run an example to identify shortest paths in GDS.
